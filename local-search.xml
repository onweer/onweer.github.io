<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于mobx</title>
    <link href="/2022/10/09/%E5%85%B3%E4%BA%8Emobx/"/>
    <url>/2022/10/09/%E5%85%B3%E4%BA%8Emobx/</url>
    
    <content type="html"><![CDATA[<h1 id="关于-mobx"><a href="#关于-mobx" class="headerlink" title="关于 mobx"></a>关于 mobx</h1><p>MobX 是一个简单、可扩展且经过实战考验的状态管理解决方案,。 MobX 是一个独立的库，但大多数人将它与 React 一起使用</p><h2 id="The-core-idea"><a href="#The-core-idea" class="headerlink" title="The core idea"></a>The core idea</h2><p><img src="/img/mobx/mobx-flow1.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>mobx6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx计算属性使用action的问题</title>
    <link href="/2022/09/29/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/mobx%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8action%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/29/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/mobx%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8action%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="如果在-mobx-计算属性中，使用-action-会发生什么"><a href="#如果在-mobx-计算属性中，使用-action-会发生什么" class="headerlink" title="如果在 mobx 计算属性中，使用 action 会发生什么"></a>如果在 mobx 计算属性中，使用 action 会发生什么</h1><p>情况 1:<br>如果 computed 属性 执行的 action，不会让 computed 再次计算，就不会有问题</p><p><img src="/img/mobx/mobx%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8action%E7%9A%84%E9%97%AE%E9%A2%981.png"></p><p>情况 2:</p><p>如果 computed 属性 执行的 action，会让 computed 再次计算，就会进入死循环</p><p><img src="/img/mobx/mobx%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8action%E7%9A%84%E9%97%AE%E9%A2%982.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>bug</tag>
      
      <tag>mobx action</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟mobx-computed-property计算属性</title>
    <link href="/2022/09/29/%E6%A8%A1%E6%8B%9Fmobx-computed-property%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/09/29/%E6%A8%A1%E6%8B%9Fmobx-computed-property%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟-Mock-的计算属性"><a href="#模拟-Mock-的计算属性" class="headerlink" title="模拟 Mock 的计算属性"></a>模拟 Mock 的计算属性</h1><p>Mock 的计算属性都是不可读写的，不能直接修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>();<br>store.<span class="hljs-property">computedX</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><p>需要使用<code>jest.spyOn</code>模拟<code>get</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">jest.<span class="hljs-title function_">spyOn</span>(storeClass, <span class="hljs-string">&#x27;computedProperty&#x27;</span>, <span class="hljs-string">&#x27;get&#x27;</span>).<span class="hljs-title function_">mockReturnValue</span>(...)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>jest</tag>
      
      <tag>mobx</tag>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年下半年职业规划</title>
    <link href="/2022/09/27/2022%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    <url>/2022/09/27/2022%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-年下半年发展规划"><a href="#2022-年下半年发展规划" class="headerlink" title="2022 年下半年发展规划"></a>2022 年下半年发展规划</h1><p><strong>有前辈的指点是幸福的, 受前辈的熏陶是幸运的, 能让我们少走很多弯路。</strong></p><hr><pre><code class="hljs">从三个方面来提升自己，第一是提升硬实力，第二是提升效率，第三是复盘总结，那个方向都需要有产出，如产出代码/文档。</code></pre><ol><li><p>首先做一个优秀的程序员，练就扎实的硬技能，需要有产出</p><p>1.1 深入学习 React 和 Mobx 运行原理，常用功能需要做一个示例代码出来，提升编码能力。</p><p>1.2 深入学习 CSS LESS CSS3 动画运行原理，每个知识点写一个产出一个示例代码，提升编码能力。</p><p>1.3 深入了解 React 性能优化，总结常见的性能问题例子，产出性能优化前后对比的代码示例。</p></li><li><p>掌握工作流程和方法，提高沟通效率 （软技能/辅助技能），需要说到做到</p><p>2.1 严格要求执行 OKG 团队工作流程</p><p>2.2 X-Y 问题 （提高沟通效率）</p><p>2.3 需求评审，技术评审，需要产出高质量技术文档。和 leader 过详细设计方案。</p></li><li><p>提升发现问题/解决问题/总结问题的能力</p><p>3.1 提出问题前，多思考问题究竟是什么？</p><p>3.2 解决问题，</p><p>3.3 总结，复盘，问题的原因。提出改进措施。</p></li><li><p>主动做事的执行力,内驱力</p><p>4.1 给你什么做什么 -&gt; 没人给你时, 自己决定做什么, 思考怎么做, 为什么做</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>职业发展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作流程和方法</title>
    <link href="/2022/09/27/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <url>/2022/09/27/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>盒模型</title>
    <link href="/2022/08/25/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/08/25/%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，是我们使用 CSS 实现准确布局、处理元素排列的关键。</p><h1 id="块级盒子（Block-box）-和-内联盒子（Inline-box）"><a href="#块级盒子（Block-box）-和-内联盒子（Inline-box）" class="headerlink" title="块级盒子（Block box） 和 内联盒子（Inline box）"></a>块级盒子（Block box） 和 内联盒子（Inline box）</h1><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (block box) 和 <strong>内联盒子</strong> (inline box)。这两种盒子会在<strong>页面流</strong>（page flow）和元素之间的关系方面表现出不同的行为：</p><p><strong>一个被定义成块级的（block）盒子会表现出以下行为：</strong></p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li><li>每个盒子都会换行</li><li>width 和 height 属性可以发挥作用</li><li>内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开”</li></ul><p>除非特殊指定，诸如标题 (<h1>等) 和段落 (<p>) 默认情况下都是块级的盒子。</p><p><strong>如果一个盒子对外显示为 inline，那么他的行为如下：</strong></p><ul><li>盒子不会产生换行。</li><li>width 和 height 属性将不起作用。</li><li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。</li><li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。</li></ul><p>用做链接的 <a> 元素、 <span>、 <em> 以及 <strong> 都是默认处于 inline 状态的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS选择器</title>
    <link href="/2022/08/25/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2022/08/25/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="选择器列表"><a href="#选择器列表" class="headerlink" title="选择器列表"></a>选择器列表</h1><p>如果你有多个使用相同样式的 CSS 选择器，那么这些单独的选择器可以被混编为一个“选择器列表”，这样，规则就可以应用到所有的单个选择器上了。例如，如果我的h1和.special类有相同的 CSS，那么我可以把它们写成两个分开的规则。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>我也可以将它们组合起来，在它们之间加上一个逗号，变为选择器列表。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-class">.special</span> &#123;<br><span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择器的种类"><a href="#选择器的种类" class="headerlink" title="选择器的种类"></a>选择器的种类</h1><p>有几组不同的选择器，知道了需要哪种选择器，你会更容易正确使用它们。在本文的子篇中，我们将会来更详细地看下不同种类的选择器。</p><p>类型、类和 ID 选择器<br>这个选择器组，第一个是指向了所有 HTML 元素<h1>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>它也包含了一个 class 的选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>亦或，一个 id 选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#unique</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="标签属性选择器"><a href="#标签属性选择器" class="headerlink" title="标签属性选择器"></a>标签属性选择器</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>或者根据一个有特定值的标签属性是否存在来选择：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;https://example.com&quot;</span>]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h2><p>这组选择器包含了伪类，用来样式化一个元素的特定状态。例如:hover伪类会在鼠标指针悬浮到一个元素上的时候选择这个元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>它还可以包含了伪元素，选择一个元素的某个部分而不是元素自己。例如，::first-line是会选择一个元素（下面的情况中是<p>）中的第一行，类似<span>包在了第一个被格式化的行外面，然后选择这个<span>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>最后一组选择器可以将其他选择器组合起来，更复杂的选择元素。下面的示例用运算符（&gt;）选择了<article>元素的初代子元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span> &#123; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less">选择器示例学习 <span class="hljs-selector-tag">CSS</span> 的教程<br>类型选择器<span class="hljs-selector-tag">h1</span> &#123; &#125;类型选择器<br>通配选择器* &#123; &#125;通配选择器<br>类选择器<span class="hljs-selector-class">.box</span> &#123; &#125;类选择器<br><span class="hljs-selector-tag">ID</span> 选择器<span class="hljs-selector-id">#unique</span> &#123; &#125;<span class="hljs-selector-tag">ID</span> 选择器<br>标签属性选择器<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;标签属性选择器<br>伪类选择器<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span><span class="hljs-selector-tag">-child</span> &#123; &#125;伪类<br>伪元素选择器<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;伪元素<br>后代选择器<span class="hljs-selector-tag">article</span> <span class="hljs-selector-tag">p</span>后代运算符<br>子代选择器<span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span>子代选择器<br>相邻兄弟选择器<span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span>相邻兄弟<br>通用兄弟选择器<span class="hljs-selector-tag">h1</span> ~ <span class="hljs-selector-tag">p</span>通用兄弟<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS理解本质</title>
    <link href="/2022/08/25/CSS%E7%90%86%E8%A7%A3%E6%9C%AC%E8%B4%A8/"/>
    <url>/2022/08/25/CSS%E7%90%86%E8%A7%A3%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h1><p>CSS 为控制继承提供了五个特殊的通用属性值。每个 css 属性都接收这些值。</p><p><strong>inherit</strong><br>设置该属性会使子元素属性和父元素相同。实际上，就是 “开启继承”.</p><p><strong>initial</strong><br>设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 inherit 。</p><p><strong>revert (en-US)</strong><br>将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。在许多情况下，此值的作用类似于 unset。</p><p><strong>revert-layer (en-US)</strong><br>将应用于选定元素的属性值重置为在上一个层叠层中建立的值。</p><p><strong>unset</strong><br>将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样</p><h1 id="理解层叠"><a href="#理解层叠" class="headerlink" title="理解层叠"></a>理解层叠</h1><p>有三个因素需要考虑，根据重要性排序如下，前面的更重要：</p><ul><li>重要程度</li><li>优先级</li><li>资源顺序</li></ul><p><strong>资源顺序</strong><br>我们已经看到了顺序对于层叠的重要性。如果你有超过一条规则，而且都是相同的权重，那么最后面的规则会应用。可以理解为后面的规则覆盖前面的规则，直到最后一个开始设置样式。</p><p><strong>优先级</strong><br>在你了解了顺序的重要性后，会发现在一些情况下，有些规则在最后出现，但是却应用了前面的规则。这是因为前面的有更高的优先级 — 它范围更小，因此浏览器就把它选择为元素的样式。</p><ol><li>千位： 如果声明在 style 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是 1000。</li><li>百位： 选择器中包含 ID 选择器则该位得一分。</li><li>十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</li><li>个位：选择器中包含元素、伪元素选择器则该位得一分。</li></ol><blockquote><p>备注： 通用选择器 (*)，组合符 (+, &gt;, ~, ‘ ‘)，和否定伪类 (:not) 不会影响优先级。</p></blockquote><blockquote><p>警告： 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。</p></blockquote><table><thead><tr><th>选择器</th><th>千位</th><th>百位</th><th>十位</th><th>个位</th><th>优先级</th></tr></thead><tbody><tr><td>h1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0001</td></tr><tr><td>h1 + p::first-letter</td><td>0</td><td>0</td><td>0</td><td>3</td><td>0003</td></tr><tr><td>li &gt; a[href*=”en-US”] &gt; .inline-warning</td><td>0</td><td>0</td><td>2</td><td>2</td><td>0022</td></tr><tr><td>#identifier</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0100</td></tr><tr><td>内联样式</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr></tbody></table><h2 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h2><p>有一个特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用 — !important。用于修改特定属性的值， 能够覆盖普通规则的层叠。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>盒子对齐规范</title>
    <link href="/2022/08/25/%E7%9B%92%E5%AD%90%E5%AF%B9%E9%BD%90%E8%A7%84%E8%8C%83/"/>
    <url>/2022/08/25/%E7%9B%92%E5%AD%90%E5%AF%B9%E9%BD%90%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="box-alignment-模块"><a href="#box-alignment-模块" class="headerlink" title="box alignment 模块"></a>box alignment 模块</h1><p>许多人开始关注 flexbox 的最初原因是在 flex 容器中能够很好的对齐其中的元素。flexbox 可以设置在其交叉轴以及主轴上的对齐属性。</p><p>这些属性最开始出现在 flexbox 规范中，现在已经成为<a href="https://www.w3.org/TR/css-align-3/">Box Alignment 规范</a>的一部分。这个规范详细说明了在所有布局中（不仅仅是 flexbox）对齐属性是如何起作用的。对齐属性用于设置元素对齐方式和沿轴的空间分配。</p><p>之所以在 flexbox 规范和 box alignment 模块规范中都有对对齐属性的详细描述，是为了确保 flexbox 规范的完成不会受 box alignment 模块规范的影响，因为后者需要详细说明所有的布局类型中的对齐方法。flexbox 规范中有一条注释指出将来一旦 Box Alignment Level 3 完成，它将会取代 flexbox 规范中的相关定义：</p><h2 id="gap-属性"><a href="#gap-属性" class="headerlink" title="gap 属性"></a>gap 属性</h2><p>属性<code>row-gap</code> 和 <code>column-gap</code>，其简写为<code>gap</code>,近期添加到了盒子布局规范中。这些属性（名称为<code>grid-row-gap</code>, <code>grid-column-gap</code> and <code>grid-gap</code>）最初定义在 CSS 网格布局中。但是他们被重命名并移入盒子布局规范。这样的话，所有的布局方法都可以使用这些属性。</p><p>不过在浏览器实现 Flex 的这些属性之前只能通过<code>margin</code> 来控制元素之间的间隙距离。</p><h2 id="Write-Mode-写作模式"><a href="#Write-Mode-写作模式" class="headerlink" title="Write Mode 写作模式"></a>Write Mode 写作模式</h2><p>书写模式规范定义了以下<code>writing-mode</code>属性值，这些值用于更改块在页面上的布局方向，以匹配在特定书写模式下格式化内容时块的布局方向。</p><ul><li>horizontal-tb</li><li>vertical-rl</li><li>vertical-lr</li><li>sideways-rl</li><li>sideways-lr</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">writing-mode</span>: vertical-lr;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Flexbox-和布局方式"><a href="#Flexbox-和布局方式" class="headerlink" title="Flexbox 和布局方式"></a>Flexbox 和布局方式</h2><p>flex会创建BFC</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-class">.box</span>&gt;* &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <br></code></pre></td></tr></table></figure><h2 id="Flexbox-和网格布局"><a href="#Flexbox-和网格布局" class="headerlink" title="Flexbox 和网格布局"></a>Flexbox 和网格布局</h2><p>CSS Grid Layout和 Flexbox 通常以相同的方式覆盖其他方法。但是，您可能希望使用 flexbox 作为网格布局的后备，因为在旧浏览器中对 flexbox 有更好的支持。</p><p>这种方法效果很好。如果弹性项目成为网格项目，则flex可能已分配给子元素的属性将被忽略。</p><p>在 Grid Layout 中，您对容器进行大部分尺寸规范，设置轨道，然后将项目放入其中。在 flexbox 中，当您创建一个 flex 容器并在该级别设置方向时，对项目大小的任何控制都需要在项目本身上进行。</p><h2 id="Flexbox-和显示：内容"><a href="#Flexbox-和显示：内容" class="headerlink" title="Flexbox 和显示：内容"></a>Flexbox 和显示：内容</h2><p>该属性的contents值display是规范中描述的新值，如下所示：</p><blockquote><p>“元素本身不会生成任何框，但它的子元素和伪元素仍然照常生成框。出于框生成和布局的目的，必须将元素视为已被文档树中的子元素和伪元素替换。”</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.nested</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: orange;<br>    <span class="hljs-attribute">display</span>: contents;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h2 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">flex<br>flex-basis<br>flex-direction<br>flex-flow<br>flex-grow<br>flex-shrink<br>flex-wrap<br>order<br><br>align-content<br>align-items<br>align-self<br>justify-content<br>place-content<br>row-gap 行间隙<br>column-gap 列间隙<br>gap 行和列间隙，该属性是row-gap和column-gap的简写<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
      <tag>gap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2022/08/24/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2022/08/24/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Flexible-Box-模型"><a href="#Flexible-Box-模型" class="headerlink" title="Flexible Box 模型"></a>Flexible Box 模型</h1><p>是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力</p><h1 id="两根轴线"><a href="#两根轴线" class="headerlink" title="两根轴线"></a>两根轴线</h1><p>当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴。主轴由 <code>flex-direction</code> 定义，另一根轴垂直于它。</p><h2 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h2><p>主轴由 <code>flex-direction</code> 定义，可以取 4 个值：</p><ul><li>row</li><li>row-reverse</li><li>column</li><li>column-reverse</li></ul><p>如果你选择了 row 或者 row-reverse，你的主轴将沿着 inline 方向延伸。</p><p><img src="/img/css/flex01.png"></p><p>选择 <code>column</code> 或者 <code>column-reverse</code> 时，你的主轴会沿着上下方向延伸 — 也就是 block 排列的方向。</p><p><img src="/img/css/flex02.png"></p><h2 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h2><p>交叉轴垂直于主轴，所以如果你的<code>flex-direction</code> (主轴) 设成了 <code>row</code> 或者 <code>row-reverse</code> 的话，交叉轴的方向就是沿着列向下的。</p><p><img src="/img/css/flex03.png"></p><p>如果主轴方向设成了 <code>column</code> 或者 <code>column-reverse</code>，交叉轴就是水平方向。</p><p><img src="/img/css/flex04.png"></p><h1 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h1><p>文档中采用了 flexbox 的区域就叫做 flex 容器。为了创建 <code>flex</code> 容器，我们把一个容器的 <code>display</code> 属性值改为 <code>flex</code> 或者 <code>inline-flex</code></p><p>完成这一步之后，容器中的直系子元素就会变为 <strong>flex 元素</strong>。所有 CSS 属性都会有一个初始值，所以 flex 容器中的所有 flex 元素都会有下列行为：</p><ul><li>元素排列为一行 (flex-direction 属性的初始值是 row)。</li><li>元素从主轴的起始线开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。</li><li>元素被拉伸来填充交叉轴大小。</li><li>flex-basis 属性为 auto。</li><li>flex-wrap 属性为 nowrap。</li></ul><p>这会让你的元素呈线形排列，并且把自己的大小作为主轴上的大小。如果有太多元素超出容器，它们会溢出而<strong>不会换行</strong>。如果一些元素比其他元素高，那么元素会沿交叉轴被拉伸来填满它的大小。</p><h1 id="更改-flex-方向-flex-direction"><a href="#更改-flex-方向-flex-direction" class="headerlink" title="更改 flex 方向 flex-direction"></a>更改 flex 方向 flex-direction</h1><p>把 flex 容器的属性 flex-direction 改为 column ，主轴和交叉轴交换，元素沿着列的方向排列显示。</p><h1 id="用-flex-wrap-实现多行-Flex-容器"><a href="#用-flex-wrap-实现多行-Flex-容器" class="headerlink" title="用 flex-wrap 实现多行 Flex 容器"></a>用 flex-wrap 实现多行 Flex 容器</h1><p>虽然flexbox是一维模型，但可以使我们的flex项目应用到多行中。在这样做的时候，您应该把每一行看作一个新的flex容器。<strong>任何空间分布都将在该行上发生</strong>，而不影响该空间分布的其他行。</p><h1 id="简写属性-flex-flow"><a href="#简写属性-flex-flow" class="headerlink" title="简写属性 flex-flow"></a>简写属性 flex-flow</h1><p>你可以将两个属性 flex-direction 和 flex-wrap 组合为简写属性 flex-flow。第一个指定的值为 flex-direction ，第二个指定的值为 flex-wrap.</p><h1 id="flex-元素上的属性"><a href="#flex-元素上的属性" class="headerlink" title="flex 元素上的属性"></a>flex 元素上的属性</h1><p>为了更好地控制 flex 元素，有三个属性可以作用于它们：</p><ul><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li></ul><p>在考虑这几个属性的作用之前，需要先了解一下 <strong>可用空间 available space</strong> 这个概念。这几个 flex 属性的作用其实就是改变了 flex 容器中的可用空间的行为。同时，可用空间对于 flex 元素的对齐行为也是很重要的。</p><p>假设在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占 300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox 的行为会把这 200px 的空间留在最后一个元素的后面。</p><p><img src="/img/css/flex05.png"></p><h2 id="Flex-元素属性：flex-basis"><a href="#Flex-元素属性：flex-basis" class="headerlink" title="Flex 元素属性：flex-basis"></a>Flex 元素属性：flex-basis</h2><p><strong>flex-basis 定义了该元素的空间大小</strong>（the size of that item in terms of the space），flex 容器里除了元素所占的空间以外的富余空间就是可用空间 available space。 该属性的默认值是 <code>auto</code> 。此时，浏览器会检测这个元素是否具有确定的尺寸。 在上面的例子中，所有元素都设定了宽度（width）为 100px，所以 flex-basis 的值为 100px。</p><p>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素内容的尺寸。这就解释了：我们给只要给 <code>Flex</code> 元素的父元素声明 <code>display: flex</code> ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</p><h2 id="Flex-元素属性：flex-grow"><a href="#Flex-元素属性：flex-grow" class="headerlink" title="Flex 元素属性：flex-grow"></a>Flex 元素属性：flex-grow</h2><p>flex-grow 若被赋值为一个正整数， flex 元素会以 flex-basis 为基础，沿主轴方向增长尺寸。<br>这会使该元素延展，<strong>并占据此方向轴上的可用空间（available space）</strong>。如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。</p><p>如果我们给上例中的所有元素设定 <code>flex-grow</code> 值为 1，容器中的可用空间会被这些元素<strong>平分</strong>。它们会延展以填满容器主轴方向上的空间。</p><p>flex-grow 属性可以按比例分配空间。如果第一个元素 flex-grow 值为 2，其他元素值为 1，则第一个元素将占有 2/4（上例中，即为 200px 中的 100px）, 另外两个元素各占有 1/4（各 50px）。</p><h2 id="Flex-元素属性：-flex-shrink"><a href="#Flex-元素属性：-flex-shrink" class="headerlink" title="Flex 元素属性： flex-shrink"></a>Flex 元素属性： flex-shrink</h2><p>flex-grow属性是处理 flex 元素在主轴上增加空间的问题，相反flex-shrink属性是处理 flex 元素收缩的问题。</p><h2 id="Flex-属性的简写"><a href="#Flex-属性的简写" class="headerlink" title="Flex 属性的简写"></a>Flex 属性的简写</h2><p>你可能很少看到 <code>flex-grow</code>，<code>flex-shrink</code>，和 <code>flex-basis</code> 属性单独使用，而是混合着写在 <code>flex</code> 简写形式中。 Flex 简写形式允许你把三个数值按这个顺序书写 — <code>flex-grow，flex-shrink，flex-basis</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>     <span class="hljs-attribute">display</span>: flex;<br>   &#125;<br><br>   <span class="hljs-selector-class">.one</span> &#123;<br>     <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> auto;<br>   &#125;<br><br>   <span class="hljs-selector-class">.two</span> &#123;<br>     <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> auto;<br>   &#125;<br><br>   <span class="hljs-selector-class">.three</span> &#123;<br>     <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> auto;<br>   &#125;<br>  <br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;three&quot;</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>大多数情况下可以用预定义的简写形式。在这个教程中你可能经常会看到这种写法，许多情况下你都可以这么使用。下面是几种预定义的值：</p><ul><li>flex: initial</li><li>flex: auto</li><li>flex: none</li><li>flex: <positive-number></li></ul><p><code>flex: initial</code> 是把 flex 元素重置为 Flexbox 的初始值，它相当于 flex: 0 1 auto。在这里 flex-grow 的值为 0，所以 flex 元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。 flex-basis 的值为 auto. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。</p><p><code>flex: auto</code> 等同于 flex: 1 1 auto；和上面的 flex:initial 基本相同，但是这种情况下，flex 元素在需要的时候既可以拉伸也可以收缩。</p><p><code>flex: none</code> 可以把 flex 元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的 flexbox 进行布局。</p><p><code>flex: &lt;positive-number&gt;</code> 你在教程中常看到的 flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0。元素可以在flex-basis为 0 的基础上伸缩。</p><h1 id="元素间的对齐和空间分配"><a href="#元素间的对齐和空间分配" class="headerlink" title="元素间的对齐和空间分配"></a>元素间的对齐和空间分配</h1><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p><code>Flexbox</code> 的一个关键特性是能够设置 flex 元素沿主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。<br><code>align-items align-items</code> 属性可以使元素在交叉轴方向对齐。</p><p><code>这个属性的初始值为stretch</code>，这就是为什么 <code>flex</code> 元素会默认被拉伸到最高元素的高度。实际上，它们被拉伸来填满 flex 容器 —— <strong>最高的元素定义了容器的高度</strong>。</p><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p><code>justify-content</code>属性用来使元素在主轴方向上对齐，主轴方向是通过 flex-direction 设置的方向。初始值是flex-start，元素从容器的起始线排列。但是你也可以把值设置为flex-end，从终止线开始排列，或者center，在中间排列。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>flex</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS有用的代码片段</title>
    <link href="/2022/08/24/JS%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    <url>/2022/08/24/JS%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="检查浏览器"><a href="#检查浏览器" class="headerlink" title="检查浏览器"></a>检查浏览器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isBrowser</span> = (<span class="hljs-params"></span>) =&gt; ![<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span>, <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;undefined&#x27;</span>);<br><span class="hljs-title function_">isBrowser</span>() <span class="hljs-comment">// true   if on isBrowser</span><br><span class="hljs-title function_">isBrowser</span>() <span class="hljs-comment">// false  if we are on node js or any other environment</span><br></code></pre></td></tr></table></figure><h2 id="检查是否为数字"><a href="#检查是否为数字" class="headerlink" title="检查是否为数字"></a>检查是否为数字</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isNumeric</span>(<span class="hljs-params">num</span>) &#123; <br>  <span class="hljs-keyword">return</span> !<span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">parseFloat</span>(num)) &amp;&amp; <span class="hljs-built_in">isFinite</span>(num); <br>&#125;<br><span class="hljs-title function_">isNumeric</span>(<span class="hljs-number">324</span>) <span class="hljs-comment">//true </span><br><span class="hljs-title function_">isNumeric</span>(<span class="hljs-string">&quot;Code&quot;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="检查是否为字符串"><a href="#检查是否为字符串" class="headerlink" title="检查是否为字符串"></a>检查是否为字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isString</span> = val =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;string&#x27;</span>;<br><span class="hljs-title function_">isString</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">isString</span>(<span class="hljs-string">&#x27;1234&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">isString</span>(<span class="hljs-number">345</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">maxN</span> = (<span class="hljs-params">arr, n = <span class="hljs-number">1</span></span>) =&gt; [...arr].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, n);<br><span class="hljs-title function_">maxN</span>([<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>]) <span class="hljs-comment">// 8 </span><br><span class="hljs-title function_">maxN</span>([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">23</span>]) <span class="hljs-comment">// 23</span><br></code></pre></td></tr></table></figure><h2 id="从列表中随机"><a href="#从列表中随机" class="headerlink" title="从列表中随机"></a>从列表中随机</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">random</span> = arr =&gt; arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * arr.<span class="hljs-property">length</span>)];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">random</span>([<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])) <span class="hljs-comment">// 6 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">random</span>([<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>])) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="范围生成器中的整数数组"><a href="#范围生成器中的整数数组" class="headerlink" title="范围生成器中的整数数组"></a>范围生成器中的整数数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">randomIntArrayInRange</span> = (<span class="hljs-params">min, max, n = <span class="hljs-number">1</span></span>) =&gt; <br>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(&#123; <span class="hljs-attr">length</span>: n &#125;, <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (max - min + <span class="hljs-number">1</span>)) + min);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">randomIntArrayInRange</span>(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// [ 14, 11, 15, 10, 13 ]</span><br></code></pre></td></tr></table></figure><h2 id="范围生成器中的随机整数"><a href="#范围生成器中的随机整数" class="headerlink" title="范围生成器中的随机整数"></a>范围生成器中的随机整数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">randomInteger</span> = (<span class="hljs-params">min, max</span>) =&gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (max - min + <span class="hljs-number">1</span>)) + min;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">randomInteger</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)) <span class="hljs-comment">// 6 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">randomInteger</span>(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><h2 id="获取类型"><a href="#获取类型" class="headerlink" title="获取类型"></a>获取类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getType</span> = v =&gt; v === <span class="hljs-literal">undefined</span> ? <span class="hljs-string">&#x27;undefined&#x27;</span> : v === <span class="hljs-literal">null</span> ? <span class="hljs-string">&#x27;null&#x27;</span> : v.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>();<br><span class="hljs-title function_">getType</span>([<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment">//array</span><br><span class="hljs-title function_">getType</span>(<span class="hljs-string">&quot;JavaScript&quot;</span>)  <span class="hljs-comment">//string</span><br><span class="hljs-title function_">getType</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">//boolean</span><br></code></pre></td></tr></table></figure><h2 id="数组平均数"><a href="#数组平均数" class="headerlink" title="数组平均数"></a>数组平均数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">average</span> = arr =&gt; arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, val</span>) =&gt;</span> acc + val, <span class="hljs-number">0</span>) / arr.<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// average([1,2,3]) -&gt; 2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/24/hello-world/"/>
    <url>/2022/08/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
