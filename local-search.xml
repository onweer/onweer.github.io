<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>reactv18-jsx</title>
    <link href="/2022/10/17/reactv18-jsx/"/>
    <url>/2022/10/17/reactv18-jsx/</url>
    
    <content type="html"><![CDATA[<h1 id="jsx-简介"><a href="#jsx-简介" class="headerlink" title="jsx 简介"></a>jsx 简介</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>这个有趣的标签语法既不是字符串也不是 HTML。</p><p>它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模板语言，但它具有 JavaScript 的全部功能。</p><h1 id="为什么使用-JSX？"><a href="#为什么使用-JSX？" class="headerlink" title="为什么使用 JSX？"></a>为什么使用 JSX？</h1><p>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。</p><p>React 并没有采用将标记与逻辑分离到不同文件这种人为的分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。我们将在后面章节中深入学习组件。如果你还没有适应在 JS 中使用标记语言，这个会议讨论应该可以说服你。</p><p>React 不强制要求使用 JSX，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。</p><h2 id="在-JSX-中嵌入表达式"><a href="#在-JSX-中嵌入表达式" class="headerlink" title="在 JSX 中嵌入表达式"></a>在 JSX 中嵌入表达式</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Josh Perez&quot;</span>;<br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><h2 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h2><p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getGreeting</span>(<span class="hljs-params">user</span>) &#123;<br>  <span class="hljs-keyword">if</span> (user) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, Stranger.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="JSX-中指定属性"><a href="#JSX-中指定属性" class="headerlink" title="JSX 中指定属性"></a>JSX 中指定属性</h2><p>你可以通过使用引号，来将属性值指定为字符串字面量：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.reactjs.org&quot;</span>&gt;</span> link <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>也可以使用大括号，来在属性值中插入一个 JavaScript 表达式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><h2 id="JSX-防止注入攻击"><a href="#JSX-防止注入攻击" class="headerlink" title="JSX 防止注入攻击"></a>JSX 防止注入攻击</h2><p>你可以安全地在 JSX 当中插入用户输入内容：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> title = response.<span class="hljs-property">potentiallyMaliciousInput</span>;<br><span class="hljs-comment">// 直接使用是安全的：</span><br><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure><p>React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。</p><h1 id="JSX-表示对象"><a href="#JSX-表示对象" class="headerlink" title="JSX 表示对象"></a>JSX 表示对象</h1><p>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</p><p>以下两种示例代码完全等效：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;greeting&quot;</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br><br><span class="hljs-keyword">const</span> element = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>  <span class="hljs-string">&quot;h1&quot;</span>,<br>  &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;greeting&quot;</span> &#125;,<br>  <span class="hljs-string">&quot;Hello, world!&quot;</span><br>);<br></code></pre></td></tr></table></figure><h1 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h1><p>元素是构成 React 应用的最小砖块。</p><p>与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。</p><h2 id="将一个元素渲染为-DOM"><a href="#将一个元素渲染为-DOM" class="headerlink" title="将一个元素渲染为 DOM"></a>将一个元素渲染为 DOM</h2><p>假设你的 HTML 文件某处有一个 <div>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们将其称为“根” DOM 节点，因为该节点内的所有内容都将由 React DOM 管理。</p><p>仅使用 React 构建的应用通常只有单一的根 DOM 节点。如果你在将 React 集成进一个已有应用，那么你可以在应用中包含任意多的独立根 DOM 节点。</p><h2 id="更新已渲染的元素"><a href="#更新已渲染的元素" class="headerlink" title="更新已渲染的元素"></a>更新已渲染的元素</h2><p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p><p>根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 root.render()。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> element = (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>  root.<span class="hljs-title function_">render</span>(element);<br>&#125;<br><br><span class="hljs-built_in">setInterval</span>(tick, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h2 id="组件-amp-Props"><a href="#组件-amp-Props" class="headerlink" title="组件 &amp; Props"></a>组件 &amp; Props</h2><p>函数组件与 class 组件<br>定义组件最简单的方式就是编写 JavaScript 函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h2><p>组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。</p><h2 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h2><p>将组件拆分为更小的组件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>react18</tag>
      
      <tag>jsx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx-理解响应性</title>
    <link href="/2022/10/13/mobx-%E7%90%86%E8%A7%A3%E5%93%8D%E5%BA%94%E6%80%A7/"/>
    <url>/2022/10/13/mobx-%E7%90%86%E8%A7%A3%E5%93%8D%E5%BA%94%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Mobx-会对跟踪函数执行时读取的任何-存在的-可观察的-属性-做出响应。"><a href="#Mobx-会对跟踪函数执行时读取的任何-存在的-可观察的-属性-做出响应。" class="headerlink" title="Mobx 会对跟踪函数执行时读取的任何 存在的 可观察的 属性 做出响应。"></a>Mobx 会对跟踪函数执行时读取的任何 存在的 可观察的 属性 做出响应。</h1><ul><li>“读取” 使用一个对象的属性, “读取”有两种方式。一种是点访问（dotting into），例如 user.name 。另一种是方括号访问，例如 user[‘name’]、todos[3]。</li><li>“跟踪函数” 其可以是 computed 的表达式、作为 observer 的 React 函数式组件的渲染（rendering）、作为 observer 的 React 类组件的 render() 方法，也可以是作为第一个参数传递给 <code>autorun</code> 、 <code>reaction</code> 和 <code>when</code> 的函数。</li><li>“跟踪函数执行时” 这意味着只有那些在跟踪函数执行时读取的可观察对象才会被跟踪。这些值在跟踪函数中是直接使用还是间接使用并不重要。但是从函数“引发”出来的东西将不会被跟踪（例如， setTimeout promise.then， await 等）。</li></ul><h2 id="换句话说，MobX-将不会对下面的情况做出响应："><a href="#换句话说，MobX-将不会对下面的情况做出响应：" class="headerlink" title="换句话说，MobX 将不会对下面的情况做出响应："></a>换句话说，MobX 将不会对下面的情况做出响应：</h2><ul><li>从可观察对象中获取到，但是并没有在跟踪函数中使用的值</li><li>在<strong>异步调用</strong>的代码块中读取的可观察值</li></ul><h2 id="MobX-跟踪属性的访问，而不是属性的值本身"><a href="#MobX-跟踪属性的访问，而不是属性的值本身" class="headerlink" title="MobX 跟踪属性的访问，而不是属性的值本身"></a>MobX 跟踪属性的访问，而不是属性的值本身</h2><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;<br>  title;<br>  author;<br>  likes;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, likes</span>) &#123;<br>    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">likes</span> = likes;<br>  &#125;<br><br>  <span class="hljs-title function_">updateTitle</span>(<span class="hljs-params">title</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;Foo&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Michel&quot;</span> &#125;, [<span class="hljs-string">&quot;Joe&quot;</span>, <span class="hljs-string">&quot;Sara&quot;</span>]);<br></code></pre></td></tr></table></figure><p>在内存中这个例子将会像下图所示的这样，绿色的块代表的是 可观察的 属性，注意 值本身 并不是可观察的！</p><p><img src="https://zh.mobx.js.org/assets/observed-refs.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>mobx-observer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx-如何定义store-最佳实践</title>
    <link href="/2022/10/11/mobx-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89store-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/10/11/mobx-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89store-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Stores"><a href="#Stores" class="headerlink" title="Stores"></a>Stores</h1><p>官网说的 Domain Store 在我们的项目中其实就是 RootStore.</p><p>Stores 可以在任何 Flux 架构中找到，并且可以和 MVC 模式中的 controllers 做类比。 Stores 的主要职责是将 逻辑（logic） 和 状态(state) 从组件中移至一个可独立测试的单元，并能同时在前后端的 JavaScript 中使用。</p><p>大多数应用都可以从定义这两个 stores 中得到好处：一个用于 Domain 状态，另一个用于 UI 状态。</p><p>区分这两类的好处是：你可以<strong>跨前后端重用</strong>和测试 领域状态，并且可以很好地在其他应用中重用它。</p><h1 id="Domain-Store"><a href="#Domain-Store" class="headerlink" title="Domain Store"></a>Domain Store</h1><p>你的应用可以包含一个或多个 <code>domain stores</code>。 这些 stores 存储着应用的所有数据。</p><ol><li>domain store 应该和应用中的业务概念一一对应。</li><li>一个 store 通常被组织成一个树状结构，里面有多个 domain 对象。</li></ol><p>举例来说：你的产品对应一个 domain store，订单和订单线对应另一个。根据经验：如果两个东西之间是包含关系，它们通常应该在一个 store 里。 因此，store 只是在管理 domain 对象。</p><h2 id="Store-的职责"><a href="#Store-的职责" class="headerlink" title="Store 的职责:"></a>Store 的职责:</h2><ul><li>实例化领域对象，确保领域对象知道它们所属的 store。</li><li>确保每个领域对象只有一个实例。 同一个用户、订单或者待办事项不应该在内存中存储两次。 这样，你可以可以安全地使用引用，并确保正在查看的实例是最新的，而无需解析引用。 这一点在调试的时候十分快速、简单、方便。</li><li>提供后端集成，当需要时存储数据。</li><li>如果从后端接收到更新，则更新现有实例。</li><li>为应用提供一个独立、通用、可测试的组件。</li><li>要确保 store 是可测试的并且可以在服务端运行，你可能需要将实际的 websocket / http 请求移到单独的对象中，以便你可以抽象出通信层。</li><li>Store 应该只有一个实例。</li></ul><h1 id="Domain-Store-1"><a href="#Domain-Store-1" class="headerlink" title="Domain Store"></a>Domain Store</h1><p>领域对象可以直接引用其他 store 中的领域对象。</p><p>请记住：我们想让我们的操作和视图尽可能的简单，需要管理引用和自己做垃圾回收可能是一种退步。 与 Redux 等许多 Flux 架构不同，MobX 不需要对你的数据进行标准化处理，这使得业务规则、操作和用户界面这些在构建应用时 本质上 最复杂的部分变得简单得多。</p><p>domain store 示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable, autorun, runInAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;node-uuid&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TodoStore</span> &#123;<br>  authorStore;<br>  transportLayer;<br>  todos = [];<br>  isLoading = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">transportLayer, authorStore</span>) &#123;<br>    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">authorStore</span> = authorStore; <span class="hljs-comment">// 可以提供 author 的 store</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">transportLayer</span> = transportLayer; <span class="hljs-comment">// 可以发起服务端请求的东西</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">transportLayer</span>.<span class="hljs-title function_">onReceiveTodoUpdate</span>(<span class="hljs-function">(<span class="hljs-params">updatedTodo</span>) =&gt;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateTodoFromServer</span>(updatedTodo)<br>    );<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadTodos</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 从服务端拉取所有的 todo 数据</span><br>  <span class="hljs-title function_">loadTodos</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isLoading</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">transportLayer</span>.<span class="hljs-title function_">fetchTodos</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">fetchedTodos</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">runInAction</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fetchedTodos.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateTodoFromServer</span>(json));<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isLoading</span> = <span class="hljs-literal">false</span>;<br>      &#125;);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 用来自服务器的信息更新一个 Todo。保证一个 Todo 只存在一次</span><br>  <span class="hljs-comment">// 可以构建一个新的 Todo，更新一个现有的 Todo</span><br>  <span class="hljs-comment">// 如果一个 Todo 在服务器上被删除，则删除该 Todo</span><br>  <span class="hljs-title function_">updateTodoFromServer</span>(<span class="hljs-params">json</span>) &#123;<br>    <span class="hljs-keyword">let</span> todo = <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.<span class="hljs-property">id</span> === json.<span class="hljs-property">id</span>);<br>    <span class="hljs-keyword">if</span> (!todo) &#123;<br>      todo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Todo</span>(<span class="hljs-variable language_">this</span>, json.<span class="hljs-property">id</span>);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">push</span>(todo);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (json.<span class="hljs-property">isDeleted</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeTodo</span>(todo);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      todo.<span class="hljs-title function_">updateFromJson</span>(json);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 在客户端和服务器上创建一个新的 Todo</span><br>  <span class="hljs-title function_">createTodo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> todo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Todo</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">push</span>(todo);<br>    <span class="hljs-keyword">return</span> todo;<br>  &#125;<br><br>  <span class="hljs-comment">// 一个 Todo 被删除了，就从客户端内存中清除掉</span><br>  <span class="hljs-title function_">removeTodo</span>(<span class="hljs-params">todo</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">indexOf</span>(todo), <span class="hljs-number">1</span>);<br>    todo.<span class="hljs-title function_">dispose</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Todo 的领域对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Todo</span> &#123;<br>  id = <span class="hljs-literal">null</span>; <span class="hljs-comment">// todo 的唯一 id, 不可改变（immutable）。</span><br>  completed = <span class="hljs-literal">false</span>;<br>  task = <span class="hljs-string">&quot;&quot;</span>;<br>  author = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 引用一个 author 对象 (来自 authorStore)</span><br>  store = <span class="hljs-literal">null</span>;<br>  autoSave = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 指示此对象的更改是否应提交到服务器</span><br>  saveHandler = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 为自动保存 Todo 的副作用提供的清理方法 (dispose)</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">store, id = uuid.v4()</span>) &#123;<br>    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">store</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">autoSave</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">saveHandler</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">dispose</span>: <span class="hljs-literal">false</span>,<br>    &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span> = store;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">saveHandler</span> = <span class="hljs-title function_">reaction</span>(<br>      <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">asJson</span>, <span class="hljs-comment">// 观察在 JSON 中使用了的任何东西:</span><br>      <span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 如果 autoSave 为 true, 把 json 发送到服务端</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">autoSave</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-property">transportLayer</span>.<span class="hljs-title function_">saveTodo</span>(json);<br>        &#125;<br>      &#125;<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">// 在客户端和服务端中删除此 Todo</span><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-property">transportLayer</span>.<span class="hljs-title function_">deleteTodo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">removeTodo</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">asJson</span>() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>,<br>      <span class="hljs-attr">completed</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">completed</span>,<br>      <span class="hljs-attr">task</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">task</span>,<br>      <span class="hljs-attr">authorId</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span>.<span class="hljs-property">id</span> : <span class="hljs-literal">null</span>,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 使用服务端信息更新此 Todo</span><br>  <span class="hljs-title function_">updateFromJson</span>(<span class="hljs-params">json</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">autoSave</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 确保变更不会保存到服务器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">completed</span> = json.<span class="hljs-property">completed</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">task</span> = json.<span class="hljs-property">task</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-property">authorStore</span>.<span class="hljs-title function_">resolveAuthor</span>(json.<span class="hljs-property">authorId</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">autoSave</span> = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 清理 observer</span><br>  <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveHandler</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="UI-stores"><a href="#UI-stores" class="headerlink" title="UI stores"></a>UI stores</h1><p>UI 状态 store 通常对应用来说非常具体，但一般也很简单。这类 store 通常没有太多的逻辑，但会存储大量关于 UI 的松散耦合的信息。 这一点很棒，因为大多数应用在开发过程中会经常改变 UI 状态。</p><p>通常可以在 UI stores 中找到:</p><ul><li>Session 信息</li><li>应用加载阶段的信息</li><li><strong>不会存储到后端的信息</strong></li><li>影响全局 UI 的信息</li><li>Window 尺寸</li><li>可访问性信息</li><li>当前语言</li><li>当前主题</li><li><strong>会影响多个无关组件的界面状态：</strong></li><li>当前选中项</li><li>工具栏可见性等等</li><li>向导的状态</li><li>全局遮罩层的状态</li></ul><p>对于同构应用，你可能还想为 store 提供一个默认值，以便组件能正常渲染。 你可以通过 React context 把 UI 状态 store 在应用中传递下去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable, observable, computed, asStructure &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UiState</span> &#123;<br>  language = <span class="hljs-string">&quot;en_US&quot;</span>;<br>  pendingRequestCount = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// .struct 确保对象只有以 deepEqual 的方式更新时，才会触发 observer</span><br>  windowDimensions = &#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>,<br>  &#125;;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123; <span class="hljs-attr">windowDimensions</span>: observable.<span class="hljs-property">struct</span> &#125;);<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">windowDimensions</span> = <span class="hljs-title function_">getWindowDimensions</span>();<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">appIsInSync</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingRequestCount</span> === <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="组合多个-stores"><a href="#组合多个-stores" class="headerlink" title="组合多个 stores"></a>组合多个 stores</h1><p>一个经常被问到的问题是：如何在不使用单例的情况下组合多个 stores，stores 之间如何相互通信？</p><p>创建一个 RootStore 是解决这个问题的有效模式：把所有 stores 实例化，并共享引用。这种模式的优点如下：</p><ul><li>易于设置</li><li>支持强类型</li><li>因为只需要实例化一个 root store，复杂的单元测试会变得简单一点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RootStore</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">userStore</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserStore</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">todoStore</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TodoStore</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserStore</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">rootStore</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rootStore</span> = rootStore;<br>  &#125;<br><br>  <span class="hljs-title function_">getTodos</span>(<span class="hljs-params">user</span>) &#123;<br>    <span class="hljs-comment">// 通过 root store 来访问 todoStore</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">rootStore</span>.<span class="hljs-property">todoStore</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">filter</span>(<br>      <span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.<span class="hljs-property">author</span> === user<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TodoStore</span> &#123;<br>  todos = [];<br>  rootStore;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">rootStore</span>) &#123;<br>    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123; <span class="hljs-attr">rootStore</span>: <span class="hljs-literal">false</span> &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rootStore</span> = rootStore;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 React 时，root store 一般通过 React context 插入到组件树中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>mobx-store</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx优化React渲染</title>
    <link href="/2022/10/10/mobx%E4%BC%98%E5%8C%96React%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/10/10/mobx%E4%BC%98%E5%8C%96React%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="优化-React-组件渲染-🚀"><a href="#优化-React-组件渲染-🚀" class="headerlink" title="优化 React 组件渲染 {🚀}"></a>优化 React 组件渲染 {🚀}</h1><p>MobX 非常快, 通常比 Redux 更快, 但本章节提供一些小贴士，以便充分利用 React 和 MobX。 请注意，大多数小贴士都适用于一般的 React，而非 MobX 特有的。 需要注意的是，虽然这些模式都很好, 但通常应用程序速度都足够快，即使您什么都没有做。</p><h1 id="使用大量的小组件"><a href="#使用大量的小组件" class="headerlink" title="使用大量的小组件"></a>使用大量的小组件</h1><p>observer 组件将跟踪他们使用的值，并且当它们中任何一个值发生时重新渲染。所以你的组件越小，它们重新渲染产生的变化就越小。这意味着用户界面的更多部分具备彼此独立渲染的可能性。</p><h1 id="专用组件去渲染列表"><a href="#专用组件去渲染列表" class="headerlink" title="专用组件去渲染列表"></a>专用组件去渲染列表</h1><p>这点在渲染大量数据时格外重要。 React 在渲染大量数据时表现非常糟糕，因为协调器必须评估每个集合变化的集合所产生的组件。 因此，建议使用专门的组件来映射集合并渲染这个组件，且不再渲染其他组件。<br>不好的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; todos, user &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    &#123;user.name&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      &#123;todos.map((todo) =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">TodoView</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">&#123;todo&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span> /&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>));<br></code></pre></td></tr></table></figure><p>在上面的示例中，当 user.name 改变时，React 会不必要地协调所有的 TodoView 组件。尽管 TodoView 组件不会重新渲染，但是协调的过程本身是非常昂贵的。</p><p>好的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; todos, user &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    &#123;user.name&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">TodosView</span> <span class="hljs-attr">todos</span>=<span class="hljs-string">&#123;todos&#125;</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>));<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">TodosView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; todos &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    &#123;todos.map((todo) =&gt; (</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">TodoView</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">&#123;todo&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;todo.id&#125;</span> /&gt;</span></span><br><span class="language-xml">    ))&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>));<br></code></pre></td></tr></table></figure><p>不要使用数组的索引作为 key, 不用使用数组索引或者任何将来可能会改变的值作为 key 。如果需要的话为你的对象生成 ids。 还可以参见这篇 博客。</p><p>晚一点使用间接引用值<br>使用 mobx-react 时，推荐尽可能晚的使用间接引用值。 这是因为当使用 observable 间接引用值时 MobX 会自动重新渲染组件。 如果间接引用值发生在组件树的层级越深，那么需要重新渲染的组件就越少。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">慢的: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DisplayName</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;person.name&#125;</span> /&gt;</span></span>;<br>快的: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DisplayName</span> <span class="hljs-attr">person</span>=<span class="hljs-string">&#123;person&#125;</span> /&gt;</span></span>;<br></code></pre></td></tr></table></figure><h1 id="尽早绑定函数-🚀"><a href="#尽早绑定函数-🚀" class="headerlink" title="尽早绑定函数 {🚀}"></a>尽早绑定函数 {🚀}</h1><p>为了获得最佳的性能，你不得不创建大量小的 observer 组件，它们每个都用来渲染特定数据的不同部分，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">PersonNameDisplayer</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; person &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DisplayName</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;person.name&#125;</span> /&gt;</span></span><br>));<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CarNameDisplayer</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; car &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DisplayName</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;car.model&#125;</span> /&gt;</span></span><br>));<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">ManufacturerNameDisplayer</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; car &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DisplayName</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;car.manufacturer.name&#125;</span> /&gt;</span></span><br>));<br></code></pre></td></tr></table></figure><p>如果你拥有很多不同的数据，这种快速的方式就会变得很冗长。另一种方式是使用使用函数来返回想要渲染 Displayer 的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">GenericNameDisplayer</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; getName &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">DisplayName</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;getName()&#125;</span> /&gt;</span></span><br>));<br></code></pre></td></tr></table></figure><p>然后，你可以这样来使用组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params">&#123; person, car &#125;</span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">GenericNameDisplayer</span> <span class="hljs-attr">getName</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> person.name&#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">GenericNameDisplayer</span> <span class="hljs-attr">getName</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> car.model&#125; /&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">GenericNameDisplayer</span> <span class="hljs-attr">getName</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> car.manufacturer.name&#125; /&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>这种方式允许 GenericNameDisplayer 渲染任何名称的组件，你依然可以保持组件渲染在最低的限度。`</p>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>mobx-react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx-react-integration</title>
    <link href="/2022/10/10/mobx-react-integration/"/>
    <url>/2022/10/10/mobx-react-integration/</url>
    
    <content type="html"><![CDATA[<h1 id="集成-react"><a href="#集成-react" class="headerlink" title="集成 react"></a>集成 react</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span>; <span class="hljs-comment">// Or &quot;mobx-react&quot;.</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> <span class="hljs-title class_">ReactElement</span>);<br></code></pre></td></tr></table></figure><p>MobX 可以独立于 React 运行, 但是他们通常是结合在一起使用, 在 Mobx 的宗旨（The gist of MobX） 一文中你会经常看见集成 React 最重要的一部分：用于包裹 React Component 的 observer HOC 方法。</p><p>observer 是你可以自主选择的，在安装时（during installation）独立提供的 React bindings 包。 在下面的例子中,我们将使用更加轻量的 mobx-react-lite 包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br>  secondsPassed = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span> += <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br><br><span class="hljs-comment">//被`observer`包裹的函数式组件会被监听在它每一次调用前发生的任何变化</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; timer &#125;</span>) =&gt;</span> (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>));<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> <span class="hljs-attr">timer</span>=<span class="hljs-string">&#123;myTimer&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  myTimer.<span class="hljs-title function_">increaseTimer</span>();<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><code>observer</code> HOC 将自动订阅 React components 中任何 在渲染期间 被使用的 可被观察的对象 。 因此, 当任何可被观察的对象 变化 发生时候 组件会自动进行重新渲染（re-render）。 它还会确保组件在 没有变化 发生的时候不会进行重新渲染（re-render）。 但是, 更改组件的可观察对象的不可读属性, 也不会触发重新渲染（re-render）。</p><p>要想让 observer 生效, 并不需要关心这些对象 如何传递到 组件的（它们只要能传递给组件即可 ·译者注）, 只需要关心他们是否是可读的。 深层嵌套的可观察对象也没有问题, 复杂的表达式类似 todos[0].author.displayName 也是可以使用的。 与其他必须显式声明或预先计算数据依赖关系的框架（例如 selectors）相比，这种发生的订阅机制就显得更加精确和高效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>react</tag>
      
      <tag>mobx-react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx-reactions</title>
    <link href="/2022/10/10/mobx-reactions/"/>
    <url>/2022/10/10/mobx-reactions/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-reactions-处理副作用-🚀"><a href="#使用-reactions-处理副作用-🚀" class="headerlink" title="使用 reactions 处理副作用 {🚀}"></a>使用 reactions 处理副作用 {🚀}</h1><p>reactions 是需要理解的重要概念，因为他可以将 MobX 中所有的特性有机地融合在一起。 reactions 的目的是对自动发生的副作用进行建模。 它们的意义在于为你的可观察状态创建消费者，以及每当关联的值发生变化时，自动运行副作用。</p><h2 id="Autorun"><a href="#Autorun" class="headerlink" title="Autorun"></a>Autorun</h2><p>用法：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span>run(effect: (reaction) =&gt; <span class="hljs-built_in">void</span>)<br><span class="hljs-built_in">auto</span>run 函数接受一个函数作为参数，每当该函数所观察的值发生变化时，它都应该运行。 当你自己创建 <span class="hljs-built_in">auto</span>run 时，它也会运行一次。它仅仅对可观察状态的变化做出响应，比如那些你用 observable 或者 computed 注释的。<br></code></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  name;<br>  energyLevel;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> = <span class="hljs-number">100</span>;<br>    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">reduceEnergy</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> -= <span class="hljs-number">10</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">isHungry</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> &lt; <span class="hljs-number">50</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> giraffe = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Gary&quot;</span>);<br><br><span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Energy level:&quot;</span>, giraffe.<span class="hljs-property">energyLevel</span>);<br>&#125;);<br><br><span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (giraffe.<span class="hljs-property">isHungry</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now I&#x27;m hungry!&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I&#x27;m not hungry!&quot;</span>);<br>  &#125;<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now let&#x27;s change state!&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  giraffe.<span class="hljs-title function_">reduceEnergy</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码，你将会看到下面的输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">100</span><br><span class="hljs-attribute">I</span>&#x27;m not hungry!<br><span class="hljs-attribute">Now</span> let&#x27;s change state!<br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">90</span><br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">80</span><br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">70</span><br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">60</span><br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">50</span><br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">40</span><br><span class="hljs-attribute">Now</span> I&#x27;m hungry!<br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">30</span><br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">20</span><br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">10</span><br><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>正如你在上面输出的前两行看到的，两个 autorun 函数在初始化时都会运行一次。这就是在运行 for 循环前可以看到的内容。</p><p>一旦我们运行 for 循环使用 reduceEnergy action 改变 energyLevel， 每当 autorun 观察到可观察状态的变化时， 我们将会看到一条新的 log 条目被打印出来：</p><p>对于“Energy level”函数，它总是可以检测到 energyLevel 可观察对象的变化，总共发生 10 次。</p><p>对于“Now I’m hungry”函数，它总是可以检测到 isHungry 计算值的变化， 总共发生 1 次。</p><h2 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">reaction(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> value, <span class="hljs-function"><span class="hljs-params">(value, previousValue, reaction)</span> =&gt;</span> &#123; sideEffect &#125;, options?).<br></code></pre></td></tr></table></figure><p>reaction 类似于 autorun，但可以让你更加精细地控制要跟踪的可观察对象。 它接受两个函数作为参数：第一个，data 函数，其是被跟踪的函数并且其返回值将会作为第二个函数，effect 函数，的输入。 重要的是要注意，副作用只会对 data 函数中被访问过的数据做出反应，这些数据可能少于 effect 函数中实际使用的数据。</p><p>一般的模式是在 data 函数中返回你在副作用中需要的所有数据， 并以这种方式更精确地控制副作用触发的时机。 与 autorun 不同，副作用在初始化时不会自动运行，而只会在 data 表达式首次返回新值之后运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">import</span> &#123; makeAutoObservable, reaction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    name<br>    energyLevel<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> = <span class="hljs-number">100</span><br>        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br><br>    <span class="hljs-title function_">reduceEnergy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> -= <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">isHungry</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> &lt; <span class="hljs-number">50</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> giraffe = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Gary&quot;</span>)<br><br><span class="hljs-title function_">reaction</span>(<br>    <span class="hljs-function">() =&gt;</span> giraffe.<span class="hljs-property">isHungry</span>,<br>    <span class="hljs-function"><span class="hljs-params">isHungry</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (isHungry) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now I&#x27;m hungry!&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I&#x27;m not hungry!&quot;</span>)<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Energy level:&quot;</span>, giraffe.<span class="hljs-property">energyLevel</span>)<br>    &#125;<br>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now let&#x27;s change state!&quot;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    giraffe.<span class="hljs-title function_">reduceEnergy</span>()<br>&#125;<br>输出：<br><br><span class="hljs-title class_">Now</span> <span class="hljs-keyword">let</span><span class="hljs-string">&#x27;s change state!</span><br><span class="hljs-string">Now I&#x27;</span>m hungry!<br><span class="hljs-title class_">Energy</span> <span class="hljs-attr">level</span>: <span class="hljs-number">40</span><br><br></code></pre></td></tr></table></figure><h2 id="When"><a href="#When" class="headerlink" title="When"></a>When</h2><p>when(predicate: () =&gt; boolean, effect?: () =&gt; void, options?)<br>when(predicate: () =&gt; boolean, options?): Promise</p><p>when 会观察并运行给定的 predicate 函数，直到其返回 true。 一旦 predicate 返回了 true，给定的 effect 函数就会执行并且自动执行器函数将会被清理掉。</p><p>如果你没有传入 effect 函数，when 函数返回一个 Promise 类型的 disposer，并允许你手动取消。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; when, makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyResource</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123; <span class="hljs-attr">dispose</span>: <span class="hljs-literal">false</span> &#125;)<br>        <span class="hljs-title function_">when</span>(<br>            <span class="hljs-comment">// Once...</span><br>            <span class="hljs-function">() =&gt;</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isVisible</span>,<br>            <span class="hljs-comment">// ... then.</span><br>            <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispose</span>()<br>        )<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">isVisible</span>() &#123;<br>        <span class="hljs-comment">// 表示此项目是否可见.</span><br>    &#125;<br><br>    <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 清理一些资源.</span><br>    &#125;<br>&#125;<br>一旦 isVisible 变成 <span class="hljs-literal">false</span>，dispose 方法将会被调用， 并对 <span class="hljs-title class_">MyResource</span> 做一些清理操作。<br></code></pre></td></tr></table></figure><h2 id="await-when-…"><a href="#await-when-…" class="headerlink" title="await when(…)"></a>await when(…)</h2><p>如果你没有提供 effect 函数，when 将会返回一个 Promise。这样会跟 async / await 很好地结合在一起，让你可以等待可观察对象中的变化。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    await <span class="hljs-built_in">when</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> that.isVisible)<br>    <span class="hljs-comment">// etc...</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>reactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx-computeds</title>
    <link href="/2022/10/09/mobx-computeds/"/>
    <url>/2022/10/09/mobx-computeds/</url>
    
    <content type="html"><![CDATA[<p>计算值可以用来从其他可观察对象中派生信息。 计算值采用惰性求值，会缓存其输出，并且只有当其依赖的可观察对象被改变时才会重新计算。 它们在不被任何值观察时会被暂时停用。</p><p>从概念上讲，它们和电子表格中的公式非常相似，并且作用强大、不可被低估。它们可以协助减少你需要存储的状态的数量，并且是被高度优化过的。请尽可能使用它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, computed, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderLine</span> &#123;<br>  price = <span class="hljs-number">0</span>;<br>  amount = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">price</span>) &#123;<br>    <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;<br>      <span class="hljs-attr">price</span>: observable,<br>      <span class="hljs-attr">amount</span>: observable,<br>      <span class="hljs-attr">total</span>: computed,<br>    &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">total</span>() &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Computing...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">amount</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderLine</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">const</span> stop = <span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Total: &quot;</span> + order.<span class="hljs-property">total</span>);<br>&#125;);<br><span class="hljs-comment">// Computing...</span><br><span class="hljs-comment">// Total: 0</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(order.<span class="hljs-property">total</span>);<br><span class="hljs-comment">// (不会重新计算!)</span><br><span class="hljs-comment">// 0</span><br><br>order.<span class="hljs-property">amount</span> = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// Computing...</span><br><span class="hljs-comment">// (无需 autorun)</span><br><br>order.<span class="hljs-property">price</span> = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// Computing...</span><br><span class="hljs-comment">// Total: 10</span><br><br><span class="hljs-title function_">stop</span>();<br><br>order.<span class="hljs-property">price</span> = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// 计算值和 autorun 都不会被重新计算.</span><br></code></pre></td></tr></table></figure><h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>使用计算值时，请遵循下面的最佳实践：</p><ol><li>它们不应该有副作用或者更新其他可观察对象。</li><li>避免创建和返回新的可观察对象。</li><li>它们不应该依赖非可观察对象的值</li></ol><h2 id="计算值可以有-setters"><a href="#计算值可以有-setters" class="headerlink" title="计算值可以有 setters"></a>计算值可以有 setters</h2><p>你也可以为计算值定义一个 setter。需要注意的是，这些 setters 不能直接更改计算属性的值， 但是它们可以被当作派生的“逆操作”使用。setters 会被自动标记为 actions。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dimension</span> &#123;<br>  length = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">squared</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">squared</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(value);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="computed-struct-比较输出的结构"><a href="#computed-struct-比较输出的结构" class="headerlink" title="computed.struct 比较输出的结构"></a>computed.struct 比较输出的结构</h2><p>如果一个计算值在结构上等同于上一次的计算结果并且其输出不需要通知观察者，那么你可以使用 computed.struct。在通知观察者之前，它将会对结构进行比较而不是检查具体的引用是否相同。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;<br>  width = <span class="hljs-number">0</span>;<br>  height = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">makeObsevable</span>(<span class="hljs-variable language_">this</span>, &#123;<br>      <span class="hljs-attr">x</span>: observable,<br>      <span class="hljs-attr">y</span>: observable,<br>      <span class="hljs-attr">topRight</span>: computed.<span class="hljs-property">struct</span>,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">topRight</span>() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">x</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span>,<br>      <span class="hljs-attr">y</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span>,<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Options-🚀"><a href="#Options-🚀" class="headerlink" title="Options {🚀}"></a>Options {🚀}</h2><p>通常情况下，computed 是可以开箱即用的，但是可以通过传入 options 参数自定义其行为。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus">name<br>该字符串在 Spy event listeners 和 MobX developer tools 中用作调试名称。<br><br>equals<br>默认设置为 comparer.default。它充当一个比较函数，用于比较上一个值和下一个值。如果该函数认为两个值相等，那么观察者们将不会被重新计算。<br><br>在处理其他库的结构性数据和类型时，这个选项会很有用。例如，(<span class="hljs-selector-tag">a</span>, b) =&gt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.isSame</span>(b)可以被用在一个 moment 计算实例上。如果你想使用结构比较或者浅比较来确定新值是否与之前的值不同， comparer<span class="hljs-selector-class">.structural</span> 和 comparer<span class="hljs-selector-class">.shallow</span> 就会派上用场，最后还会通知观察者。<br><br>查看上面的 computed<span class="hljs-selector-class">.struct</span> 部分。<br><br>内置 comparers<br>MobX 提供了四种内置的 comparer 方法，这些方法满足 computed 的 equals 选项的大多数需求：<br><br>comparer<span class="hljs-selector-class">.identity</span> 使用全等 （===）运算符确定两个值是否相同。<br>comparer<span class="hljs-selector-class">.default</span> 与 comparer<span class="hljs-selector-class">.identity</span> 相同，但是其认为 NaN 等于 NaN。<br>comparer<span class="hljs-selector-class">.structural</span> 执行深层的结构比较以确定两个值是否相同。<br>comparer<span class="hljs-selector-class">.shallow</span> 执行浅层的结构比较以确定两个值是否相同。<br>你可以从 MobX 导入 comparer 来访问这些方法。它们也可以用于 reaction。<br><br>requiresReaction<br>推荐在非常昂贵的计算值中将这个选项设置为 true。如果你试图在响应式上下文之外读取这样的计算值——这种情况下，它可能不会被缓存起来——就会导致计算值抛出错误，而不是进行昂贵的重新计算。<br><br>keepAlive<br>这个选项会避免计算值在未被观察时被暂时停用（可以查看上面的解释）。这可能会导致内存泄漏，这种内存泄漏与我们在 reactions 中讨论到的类似。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>action</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx-action</title>
    <link href="/2022/10/09/mobx-action/"/>
    <url>/2022/10/09/mobx-action/</url>
    
    <content type="html"><![CDATA[<p>使用 actions 更新 state<br>用法：</p><ul><li>action （注解）</li><li>action(fn)</li><li>action(name, fn)</li></ul><p>所有的应用程序都有 actions。action 就是任意一段修改 state 的代码。原则上，actions 总会为了对一个事件做出响应而发生。例如，点击了一个按钮，一些输入被改变了，一个 <code>websocket</code> 消息被送达了，等等。</p><ol><li><p>它们在 transactions 内部运行。任何可观察对象在最外层的 action 完成之前都不会被更新，这一点保证了在 action 完成之前，action 执行期间生成的中间值或不完整的值对应用程序的其余部分都是不可见的。</p></li><li><p>默认情况下，不允许在 actions 之外改变 state。这有助于在代码中清楚地对状态更新发生的位置进行定位。</p></li></ol><p>action 注解应该仅用于会修改 state 的函数。派生其他信息（执行查询或者过滤数据）的函数不应该被标记为 actions，以便 MobX 可以对它们的调用进行跟踪。 带有 action 注解的成员是不可枚举的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;<br>  value = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;<br>      <span class="hljs-attr">value</span>: observable,<br>      <span class="hljs-attr">increment</span>: action,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 观察者不会看到中间状态.</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用-action-包装函数"><a href="#使用-action-包装函数" class="headerlink" title="使用 action 包装函数"></a>使用 action 包装函数</h1><p>不推荐这样使用</p><p>为了尽可能地利用 MobX 的事务性，actions 应该尽可能被传到外围。如果一个类方法会修改 state，可以将其标记为 action。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ResetButton</span> = (<span class="hljs-params">&#123; formState &#125;</span>) =&gt; (<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;action((e)</span> =&gt;</span> &#123;</span><br><span class="language-xml">      formState.resetPendingUploads();</span><br><span class="language-xml">      formState.resetValues();</span><br><span class="language-xml">      e.stopPropagation();</span><br><span class="language-xml">    &#125;)&#125;</span><br><span class="language-xml">  &gt;</span><br><span class="language-xml">    Reset form</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><h1 id="action-bound-推荐"><a href="#action-bound-推荐" class="headerlink" title="action.bound 推荐"></a>action.bound 推荐</h1><p>action.bound 注解可用于将方法自动绑定到正确的实例，这样 this 会始终被正确绑定在函数内部。</p><p>使用 makeAutoObservable(o, {}, { autoBind: true }) 自动绑定所有的 actions 和 flows</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;<br>  value = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123;&#125;, &#123; <span class="hljs-attr">autoBind</span>: <span class="hljs-literal">true</span> &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++;<br>  &#125;<br><br>  *<span class="hljs-title function_">flow</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://example.com/value&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-keyword">yield</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="runInAction"><a href="#runInAction" class="headerlink" title="runInAction"></a>runInAction</h1><p><code>runInAction(fn)</code></p><p>使用这个工具函数来创建一个会被立即调用的临时 action。在异步进程中非常有用。 请查看 上面代码块 中的实例。</p><h1 id="action-继承"><a href="#action-继承" class="headerlink" title="action 继承"></a>action 继承</h1><p>只有定义在原型上的函数可以被子类覆盖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-comment">// on instance</span><br>    arrowAction = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br><br>    <span class="hljs-comment">// on prototype</span><br>    <span class="hljs-title function_">action</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-title function_">boundAction</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;<br>            <span class="hljs-attr">arrowAction</span>: action<br>            <span class="hljs-attr">action</span>: action,<br>            <span class="hljs-attr">boundAction</span>: action.<span class="hljs-property">bound</span>,<br>        &#125;)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>    <span class="hljs-comment">// THROWS: TypeError: Cannot redefine property: arrowAction</span><br>    arrowAction = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br><br>    <span class="hljs-comment">// OK</span><br>    <span class="hljs-title function_">action</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-title function_">boundAction</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>()<br>        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;<br>            <span class="hljs-attr">arrowAction</span>: override,<br>            <span class="hljs-attr">action</span>: override,<br>            <span class="hljs-attr">boundAction</span>: override,<br>        &#125;)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="异步-actions"><a href="#异步-actions" class="headerlink" title="异步 actions"></a>异步 actions</h1><p>从本质上讲，异步进程在 MobX 中不需要任何特殊处理，因为不论是何时引发的所有 reactions 都将会自动更新。 而且因为可观察对象是可变的，因此在 action 执行过程中保持对它们的引用一般是安全的。</p><p>然而，<strong>在异步进程中更新可观察对象的每个步骤（tick）都应该被标识为 action</strong></p><p>我们可以通过利用上述的 API 以多种方式实现这一点，如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">如果 <span class="hljs-title class_">Promise</span> 的处理函数是类的字段，它们将由 makeAutoObservable 自动包装为 action：<br><br><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    githubProjects = []<br>    state = <span class="hljs-string">&quot;pending&quot;</span> <span class="hljs-comment">// &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;<br><br>    <span class="hljs-title function_">fetchProjects</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = []<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span><br>        <span class="hljs-title function_">fetchGithubProjectsSomehow</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projectsFetchSuccess</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">projectsFetchFailure</span>)<br>    &#125;<br><br>    projectsFetchSuccess = <span class="hljs-function"><span class="hljs-params">projects</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> filteredProjects = <span class="hljs-title function_">somePreprocessing</span>(projects)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = filteredProjects<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;done&quot;</span><br>    &#125;<br><br>    projectsFetchFailure = <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;error&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pf">await 之后的任何操作都不与其同在一个 tick 中，因此它们需要使用 action 包装。 在这里，我们可以利用 runInAction：<br><br>import &#123; runInAction, makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><br><br>class Store &#123;<br>    githubProjects = []<br>    <span class="hljs-keyword">state</span> = <span class="hljs-string">&quot;pending&quot;</span> // <span class="hljs-string">&quot;pending&quot;</span>, <span class="hljs-string">&quot;done&quot;</span> or <span class="hljs-string">&quot;error&quot;</span><br><br>    constructor() &#123;<br>        makeAutoObservable(this)<br>    &#125;<br><br>    async fetchProjects() &#123;<br>        this.githubProjects = []<br>        this.<span class="hljs-keyword">state</span> = <span class="hljs-string">&quot;pending&quot;</span><br>        try &#123;<br>            <span class="hljs-keyword">const</span> projects = await fetchGithubProjectsSomehow()<br>            <span class="hljs-keyword">const</span> filteredProjects = somePreprocessing(projects)<br>            runInAction(() =&gt; &#123;<br>                this.githubProjects = filteredProjects<br>                this.<span class="hljs-keyword">state</span> = <span class="hljs-string">&quot;done&quot;</span><br>            &#125;)<br>        &#125; catch (e) &#123;<br>            runInAction(() =&gt; &#123;<br>                this.<span class="hljs-keyword">state</span> = <span class="hljs-string">&quot;error&quot;</span><br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用-flow-代替-async-await-🚀"><a href="#使用-flow-代替-async-await-🚀" class="headerlink" title="使用 flow 代替 async / await {🚀}"></a>使用 flow 代替 async / await {🚀}</h1><ul><li>flow （注解）</li><li>flow(function* (args) { })</li></ul><p>flow 包装器是一个可选的 async / await 替代方案，它让 MobX action 使用起来更加容易。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>action</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx-observable-state</title>
    <link href="/2022/10/09/mobx-observable-state/"/>
    <url>/2022/10/09/mobx-observable-state/</url>
    
    <content type="html"><![CDATA[<h1 id="创建可观察的状态"><a href="#创建可观察的状态" class="headerlink" title="创建可观察的状态"></a>创建可观察的状态</h1><ul><li>属性</li><li>对象</li><li>数组</li><li>Maps</li><li>Sets</li></ul><p>都可以被转化为可观察的对象，使得对象可观察的基本方法是使用 makeObservable 为每个属性指定一个注解。 最重要的注解如下：</p><ul><li>observable 定义一个存储 state 的可追踪字段。</li><li>action 将一个方法标记为可以修改 state 的 action。</li><li>computed 标记一个可以由 state 派生出新的值并且缓存其输出的 getter。</li></ul><p>像数组，Maps 和 Sets 这样的集合都将被自动转化为可观察对象。</p><blockquote><p>makeObservable<br>用法：</p></blockquote><p><code>makeObservable(target, annotations?, options?)</code></p><p>这个函数可以捕获已经存在的对象属性并且使得它们可观察。任何 JavaScript 对象（包括类的实例）都可以作为 target 被传递给这个函数。</p><p>一般情况下，makeObservable 是在类的构造函数中调用的，并且它的第一个参数是 this</p><p>annotations 参数将会为每一个成员映射 注解。需要注意的是，当使用 装饰器 时，annotations 参数将会被忽略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, computed, action, flow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;<br>  value;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;<br>      <span class="hljs-attr">value</span>: observable,<br>      <span class="hljs-attr">double</span>: computed,<br>      <span class="hljs-attr">increment</span>: action,<br>      <span class="hljs-attr">fetch</span>: flow,<br>    &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">double</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++;<br>  &#125;<br><br>  *<span class="hljs-title function_">fetch</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/value&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = response.<span class="hljs-title function_">json</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>makeAutoObservable</code><br>用法：</p></blockquote><p><code>makeAutoObservable(target, overrides?, options?)</code></p><p>makeAutoObservable 就像是加强版的 makeObservable，在默认情况下它将推断所有的属性。你仍然可以使用 overrides 重写某些注解的默认行为。 具体来说，false 可用于从自动处理中排除一个属性或方法。 查看上面的代码分页获取示例。 与使用 makeObservable 相比，makeAutoObservable 函数更紧凑，也更容易维护，因为新成员不需要显式地提及。 然而，makeAutoObservable 不能被用于带有 super 的类或 子类。</p><p>推断规则：</p><ul><li>所有 自有 属性都成为 observable。</li><li>所有 getters 都成为 computed。</li><li>所有 setters 都成为 action。</li><li>所有 prototype 中的 functions 都成为 autoAction。</li><li>所有 prototype 中的 generator functions 都成为 flow。（需要注意，generators 函数在某些编译器配置中无法被检测到，如果 flow 没有正常运行，请务必明确地指定 flow 注解。）</li><li>在 overrides 参数中标记为 false 的成员将不会被添加注解。例如，将其用于像标识符这样的只读字段。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createDoubler</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">makeAutoObservable</span>(&#123;<br>    value,<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">double</span>() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>;<br>    &#125;,<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>observable</p></blockquote><p><code>observable(source, overrides?, options?)</code></p><p>observable 注解可以作为一个函数进行调用，从而一次性将整个对象变成可观察的。 source 对象将会被克隆并且所有的成员都将会成为可观察的，类似于 makeAutoObservable 做的那样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; observable, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;<br><br><span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">observable</span>([<br>  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Spoil tea&quot;</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">true</span> &#125;,<br>  &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Make coffee&quot;</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> &#125;,<br>]);<br><br><span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>    <span class="hljs-string">&quot;Remaining:&quot;</span>,<br>    todos<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> !todo.<span class="hljs-property">completed</span>)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.<span class="hljs-property">title</span>)<br>      .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;, &quot;</span>)<br>  );<br>&#125;);<br><span class="hljs-comment">// 打印: &#x27;Remaining: Make coffee&#x27;</span><br><br>todos[<span class="hljs-number">0</span>].<span class="hljs-property">completed</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 打印: &#x27;Remaining: Spoil tea, Make coffee&#x27;</span><br><br>todos[<span class="hljs-number">2</span>] = &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Take a nap&quot;</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-comment">// 打印: &#x27;Remaining: Spoil tea, Make coffee, Take a nap&#x27;</span><br><br>todos.<span class="hljs-title function_">shift</span>();<br><span class="hljs-comment">// 打印: &#x27;Remaining: Make coffee, Take a nap&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="observable-和-makeObservable-区别"><a href="#observable-和-makeObservable-区别" class="headerlink" title="observable 和 makeObservable 区别"></a>observable 和 makeObservable 区别</h1><p>make(Auto)Observable 和 observable 之间最主要的区别在于，make(Auto)Observable 会修改你作为第一个参数传入的对象，而 observable 会创建一个可观察的 副本 对象。</p><p>第二个区别是，observable 会创建一个 Proxy 对象，以便能够在你将该对象当作动态查询映射使用时捕获将要添加的属性。 如果你想把一个对象转化为可观察对象，而这个对象具有一个常规结构，其中所有的成员都是事先已知的，那么我们建议使用 makeObservable，因为非代理对象的速度稍快一些，而且它们在调试器和 console.log 中更容易检查。</p><p>因此，make(Auto)Observable 推荐在工厂函数中使用。 值得一提的是，可以将 { proxy: false } 作为 option 传入 observable 获取非代理副本。</p><h1 id="可用的注解"><a href="#可用的注解" class="headerlink" title="可用的注解"></a>可用的注解</h1><p><img src="/img/mobx/mobx-state1.png"></p><h2 id="option"><a href="#option" class="headerlink" title="option"></a>option</h2><p>Options {🚀}<br>上面的 API 都有一个可选的 options 参数，该参数是一个对象，支持以下选项：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">autoBind:</span> <span class="hljs-literal">true</span> 默认使用 action.bound/flow.bound，而不使用 action/flow。不影响被显式注释过的成员。<br><span class="hljs-symbol">deep:</span> <span class="hljs-literal">false</span> 默认使用 observable.ref，而不使用 observable。不影响被显式注释过的成员。<br><span class="hljs-symbol">name:</span> &lt;<span class="hljs-type">string</span>&gt; 为对象提供一个调试名称，该名称将被打印在错误消息和 reflection API 中。<br><span class="hljs-symbol">proxy:</span> <span class="hljs-literal">false</span> 迫使 observable(thing) 使用非 proxy 的实现。如果对象的结构不会随着时间变化，那么这就是一个很好的选择，因为非代理对象更容易调试并且速度更快。请参见 避免代理。<br></code></pre></td></tr></table></figure><h1 id="将-observable-转换回普通的-JavaScript-集合"><a href="#将-observable-转换回普通的-JavaScript-集合" class="headerlink" title="将 observable 转换回普通的 JavaScript 集合"></a>将 observable 转换回普通的 JavaScript 集合</h1><p>有时有必要将可观察的数据结构转换回原生的数据结构。 例如，将可观察对象传入一个无法跟踪可观察对象的 React 组件时，或者想要获取一个不会再被更改的副本时。</p><p>要进行浅转换，用常用的 JavaScript 操作就可以做到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> plainObject = &#123; ...observableObject &#125;;<br><span class="hljs-keyword">const</span> plainArray = observableArray.<span class="hljs-title function_">slice</span>();<br><span class="hljs-keyword">const</span> plainMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(observableMap);<br></code></pre></td></tr></table></figure><p>要将数据树递归地转换为普通对象，可使用 toJS 工具函数。 对于类，建议实现一个 toJSON() 方法，因为这样会被 JSON.stringify 识别出来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>observable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于mobx</title>
    <link href="/2022/10/09/%E5%85%B3%E4%BA%8Emobx/"/>
    <url>/2022/10/09/%E5%85%B3%E4%BA%8Emobx/</url>
    
    <content type="html"><![CDATA[<h1 id="关于-mobx"><a href="#关于-mobx" class="headerlink" title="关于 mobx"></a>关于 mobx</h1><p>MobX 是一个简单、可扩展且经过实战考验的状态管理解决方案,。 MobX 是一个独立的库，但大多数人将它与 React 一起使用</p><h2 id="The-core-idea"><a href="#The-core-idea" class="headerlink" title="The core idea"></a>The core idea</h2><p>状态是每个应用的核心。如果你想打造出漏洞百出又难以管理的应用程序，那么搞出不一致的状态或与徘徊着的局部变量不同步的状态就是最快的方法。</p><p>因此，许多状态管理解决方案试图限制您可以修改状态的方式，例如通过使状态不可变。但这带来了新的问题；数据需要规范化，引用完整性不再得到保证，并且几乎不可能使用强大的概念，如类，</p><p><img src="/img/mobx/mobx-flow1.png"></p><ol><li>首先是 应用状态。就是那些呈图状结构分布、组成你应用状态模型的对象、数组、原始值和引用。这些值是你应用中的“单元格”。</li><li>其次是 derivations。也就是任何可以从你的应用状态中被自动计算出来的值。这些 derivations ——或者计算值——可以是简单的值，比如未完成待办的个数；也可以是复杂的值，比如你待办清单的 HTML 视觉表示。</li><li>Reactions 与 derivations 非常相似。但主要的区别在于这些函数不会返回值，而会自动执行一些任务。通常这些任务与 I/O 有关。它们会确保 DOM 的更新或者在对的时间自动发出网络请求。</li><li>最后是 actions。actions 就是所有会修改状态的代码。MobX 会让所有由于你的 actions 引发的应用状态的改变都被全部 derivations 和 reactions 同步而顺畅地自动处理掉。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>mobx6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx计算属性使用action的问题</title>
    <link href="/2022/09/29/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/mobx%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8action%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/29/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/mobx%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8action%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="如果在-mobx-计算属性中，使用-action-会发生什么"><a href="#如果在-mobx-计算属性中，使用-action-会发生什么" class="headerlink" title="如果在 mobx 计算属性中，使用 action 会发生什么"></a>如果在 mobx 计算属性中，使用 action 会发生什么</h1><p>情况 1:<br>如果 computed 属性 执行的 action，不会让 computed 再次计算，就不会有问题</p><p><img src="/img/mobx/mobx%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8action%E7%9A%84%E9%97%AE%E9%A2%981.png"></p><p>情况 2:</p><p>如果 computed 属性 执行的 action，会让 computed 再次计算，就会进入死循环</p><p><img src="/img/mobx/mobx%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8action%E7%9A%84%E9%97%AE%E9%A2%982.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>mobx</tag>
      
      <tag>bug</tag>
      
      <tag>mobx action</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟mobx-computed-property计算属性</title>
    <link href="/2022/09/29/%E6%A8%A1%E6%8B%9Fmobx-computed-property%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <url>/2022/09/29/%E6%A8%A1%E6%8B%9Fmobx-computed-property%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟-Mock-的计算属性"><a href="#模拟-Mock-的计算属性" class="headerlink" title="模拟 Mock 的计算属性"></a>模拟 Mock 的计算属性</h1><p>Mock 的计算属性都是不可读写的，不能直接修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>();<br>store.<span class="hljs-property">computedX</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><p>需要使用<code>jest.spyOn</code>模拟<code>get</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">jest.<span class="hljs-title function_">spyOn</span>(storeClass, <span class="hljs-string">&#x27;computedProperty&#x27;</span>, <span class="hljs-string">&#x27;get&#x27;</span>).<span class="hljs-title function_">mockReturnValue</span>(...)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>jest</tag>
      
      <tag>mobx</tag>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年下半年职业规划</title>
    <link href="/2022/09/27/2022%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    <url>/2022/09/27/2022%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="2022-年下半年发展规划"><a href="#2022-年下半年发展规划" class="headerlink" title="2022 年下半年发展规划"></a>2022 年下半年发展规划</h1><p><strong>有前辈的指点是幸福的, 受前辈的熏陶是幸运的, 能让我们少走很多弯路。</strong></p><hr><pre><code class="hljs">从三个方面来提升自己，第一是提升硬实力，第二是提升效率，第三是复盘总结，那个方向都需要有产出，如产出代码/文档。</code></pre><ol><li><p>首先做一个优秀的程序员，练就扎实的硬技能，需要有产出</p><p>1.1 深入学习 React 和 Mobx 运行原理，常用功能需要做一个示例代码出来，提升编码能力。</p><p>1.2 深入学习 CSS LESS CSS3 动画运行原理，每个知识点写一个产出一个示例代码，提升编码能力。</p><p>1.3 深入了解 React 性能优化，总结常见的性能问题例子，产出性能优化前后对比的代码示例。</p></li><li><p>掌握工作流程和方法，提高沟通效率 （软技能/辅助技能），需要说到做到</p><p>2.1 严格要求执行 OKG 团队工作流程</p><p>2.2 X-Y 问题 （提高沟通效率）</p><p>2.3 需求评审，技术评审，需要产出高质量技术文档。和 leader 过详细设计方案。</p></li><li><p>提升发现问题/解决问题/总结问题的能力</p><p>3.1 提出问题前，多思考问题究竟是什么？</p><p>3.2 解决问题，</p><p>3.3 总结，复盘，问题的原因。提出改进措施。</p></li><li><p>主动做事的执行力,内驱力</p><p>4.1 给你什么做什么 -&gt; 没人给你时, 自己决定做什么, 思考怎么做, 为什么做</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>职业发展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作流程和方法</title>
    <link href="/2022/09/27/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <url>/2022/09/27/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>盒模型</title>
    <link href="/2022/08/25/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/08/25/%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，是我们使用 CSS 实现准确布局、处理元素排列的关键。</p><h1 id="块级盒子（Block-box）-和-内联盒子（Inline-box）"><a href="#块级盒子（Block-box）-和-内联盒子（Inline-box）" class="headerlink" title="块级盒子（Block box） 和 内联盒子（Inline box）"></a>块级盒子（Block box） 和 内联盒子（Inline box）</h1><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (block box) 和 <strong>内联盒子</strong> (inline box)。这两种盒子会在<strong>页面流</strong>（page flow）和元素之间的关系方面表现出不同的行为：</p><p><strong>一个被定义成块级的（block）盒子会表现出以下行为：</strong></p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li><li>每个盒子都会换行</li><li>width 和 height 属性可以发挥作用</li><li>内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开”</li></ul><p>除非特殊指定，诸如标题 (<h1>等) 和段落 (<p>) 默认情况下都是块级的盒子。</p><p><strong>如果一个盒子对外显示为 inline，那么他的行为如下：</strong></p><ul><li>盒子不会产生换行。</li><li>width 和 height 属性将不起作用。</li><li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。</li><li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。</li></ul><p>用做链接的 <a> 元素、 <span>、 <em> 以及 <strong> 都是默认处于 inline 状态的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS选择器</title>
    <link href="/2022/08/25/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2022/08/25/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="选择器列表"><a href="#选择器列表" class="headerlink" title="选择器列表"></a>选择器列表</h1><p>如果你有多个使用相同样式的 CSS 选择器，那么这些单独的选择器可以被混编为一个“选择器列表”，这样，规则就可以应用到所有的单个选择器上了。例如，如果我的h1和.special类有相同的 CSS，那么我可以把它们写成两个分开的规则。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><br><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>我也可以将它们组合起来，在它们之间加上一个逗号，变为选择器列表。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-class">.special</span> &#123;<br><span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择器的种类"><a href="#选择器的种类" class="headerlink" title="选择器的种类"></a>选择器的种类</h1><p>有几组不同的选择器，知道了需要哪种选择器，你会更容易正确使用它们。在本文的子篇中，我们将会来更详细地看下不同种类的选择器。</p><p>类型、类和 ID 选择器<br>这个选择器组，第一个是指向了所有 HTML 元素<h1>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>它也包含了一个 class 的选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>亦或，一个 id 选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#unique</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="标签属性选择器"><a href="#标签属性选择器" class="headerlink" title="标签属性选择器"></a>标签属性选择器</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>或者根据一个有特定值的标签属性是否存在来选择：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;https://example.com&quot;</span>]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h2><p>这组选择器包含了伪类，用来样式化一个元素的特定状态。例如:hover伪类会在鼠标指针悬浮到一个元素上的时候选择这个元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>它还可以包含了伪元素，选择一个元素的某个部分而不是元素自己。例如，::first-line是会选择一个元素（下面的情况中是<p>）中的第一行，类似<span>包在了第一个被格式化的行外面，然后选择这个<span>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>最后一组选择器可以将其他选择器组合起来，更复杂的选择元素。下面的示例用运算符（&gt;）选择了<article>元素的初代子元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span> &#123; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less">选择器示例学习 <span class="hljs-selector-tag">CSS</span> 的教程<br>类型选择器<span class="hljs-selector-tag">h1</span> &#123; &#125;类型选择器<br>通配选择器* &#123; &#125;通配选择器<br>类选择器<span class="hljs-selector-class">.box</span> &#123; &#125;类选择器<br><span class="hljs-selector-tag">ID</span> 选择器<span class="hljs-selector-id">#unique</span> &#123; &#125;<span class="hljs-selector-tag">ID</span> 选择器<br>标签属性选择器<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;标签属性选择器<br>伪类选择器<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span><span class="hljs-selector-tag">-child</span> &#123; &#125;伪类<br>伪元素选择器<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;伪元素<br>后代选择器<span class="hljs-selector-tag">article</span> <span class="hljs-selector-tag">p</span>后代运算符<br>子代选择器<span class="hljs-selector-tag">article</span> &gt; <span class="hljs-selector-tag">p</span>子代选择器<br>相邻兄弟选择器<span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span>相邻兄弟<br>通用兄弟选择器<span class="hljs-selector-tag">h1</span> ~ <span class="hljs-selector-tag">p</span>通用兄弟<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS理解本质</title>
    <link href="/2022/08/25/CSS%E7%90%86%E8%A7%A3%E6%9C%AC%E8%B4%A8/"/>
    <url>/2022/08/25/CSS%E7%90%86%E8%A7%A3%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h1><p>CSS 为控制继承提供了五个特殊的通用属性值。每个 css 属性都接收这些值。</p><p><strong>inherit</strong><br>设置该属性会使子元素属性和父元素相同。实际上，就是 “开启继承”.</p><p><strong>initial</strong><br>设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 inherit 。</p><p><strong>revert (en-US)</strong><br>将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。在许多情况下，此值的作用类似于 unset。</p><p><strong>revert-layer (en-US)</strong><br>将应用于选定元素的属性值重置为在上一个层叠层中建立的值。</p><p><strong>unset</strong><br>将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样</p><h1 id="理解层叠"><a href="#理解层叠" class="headerlink" title="理解层叠"></a>理解层叠</h1><p>有三个因素需要考虑，根据重要性排序如下，前面的更重要：</p><ul><li>重要程度</li><li>优先级</li><li>资源顺序</li></ul><p><strong>资源顺序</strong><br>我们已经看到了顺序对于层叠的重要性。如果你有超过一条规则，而且都是相同的权重，那么最后面的规则会应用。可以理解为后面的规则覆盖前面的规则，直到最后一个开始设置样式。</p><p><strong>优先级</strong><br>在你了解了顺序的重要性后，会发现在一些情况下，有些规则在最后出现，但是却应用了前面的规则。这是因为前面的有更高的优先级 — 它范围更小，因此浏览器就把它选择为元素的样式。</p><ol><li>千位： 如果声明在 style 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是 1000。</li><li>百位： 选择器中包含 ID 选择器则该位得一分。</li><li>十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</li><li>个位：选择器中包含元素、伪元素选择器则该位得一分。</li></ol><blockquote><p>备注： 通用选择器 (*)，组合符 (+, &gt;, ~, ‘ ‘)，和否定伪类 (:not) 不会影响优先级。</p></blockquote><blockquote><p>警告： 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。</p></blockquote><table><thead><tr><th>选择器</th><th>千位</th><th>百位</th><th>十位</th><th>个位</th><th>优先级</th></tr></thead><tbody><tr><td>h1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0001</td></tr><tr><td>h1 + p::first-letter</td><td>0</td><td>0</td><td>0</td><td>3</td><td>0003</td></tr><tr><td>li &gt; a[href*=”en-US”] &gt; .inline-warning</td><td>0</td><td>0</td><td>2</td><td>2</td><td>0022</td></tr><tr><td>#identifier</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0100</td></tr><tr><td>内联样式</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr></tbody></table><h2 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h2><p>有一个特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用 — !important。用于修改特定属性的值， 能够覆盖普通规则的层叠。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>盒子对齐规范</title>
    <link href="/2022/08/25/%E7%9B%92%E5%AD%90%E5%AF%B9%E9%BD%90%E8%A7%84%E8%8C%83/"/>
    <url>/2022/08/25/%E7%9B%92%E5%AD%90%E5%AF%B9%E9%BD%90%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="box-alignment-模块"><a href="#box-alignment-模块" class="headerlink" title="box alignment 模块"></a>box alignment 模块</h1><p>许多人开始关注 flexbox 的最初原因是在 flex 容器中能够很好的对齐其中的元素。flexbox 可以设置在其交叉轴以及主轴上的对齐属性。</p><p>这些属性最开始出现在 flexbox 规范中，现在已经成为<a href="https://www.w3.org/TR/css-align-3/">Box Alignment 规范</a>的一部分。这个规范详细说明了在所有布局中（不仅仅是 flexbox）对齐属性是如何起作用的。对齐属性用于设置元素对齐方式和沿轴的空间分配。</p><p>之所以在 flexbox 规范和 box alignment 模块规范中都有对对齐属性的详细描述，是为了确保 flexbox 规范的完成不会受 box alignment 模块规范的影响，因为后者需要详细说明所有的布局类型中的对齐方法。flexbox 规范中有一条注释指出将来一旦 Box Alignment Level 3 完成，它将会取代 flexbox 规范中的相关定义：</p><h2 id="gap-属性"><a href="#gap-属性" class="headerlink" title="gap 属性"></a>gap 属性</h2><p>属性<code>row-gap</code> 和 <code>column-gap</code>，其简写为<code>gap</code>,近期添加到了盒子布局规范中。这些属性（名称为<code>grid-row-gap</code>, <code>grid-column-gap</code> and <code>grid-gap</code>）最初定义在 CSS 网格布局中。但是他们被重命名并移入盒子布局规范。这样的话，所有的布局方法都可以使用这些属性。</p><p>不过在浏览器实现 Flex 的这些属性之前只能通过<code>margin</code> 来控制元素之间的间隙距离。</p><h2 id="Write-Mode-写作模式"><a href="#Write-Mode-写作模式" class="headerlink" title="Write Mode 写作模式"></a>Write Mode 写作模式</h2><p>书写模式规范定义了以下<code>writing-mode</code>属性值，这些值用于更改块在页面上的布局方向，以匹配在特定书写模式下格式化内容时块的布局方向。</p><ul><li>horizontal-tb</li><li>vertical-rl</li><li>vertical-lr</li><li>sideways-rl</li><li>sideways-lr</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">writing-mode</span>: vertical-lr;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Flexbox-和布局方式"><a href="#Flexbox-和布局方式" class="headerlink" title="Flexbox 和布局方式"></a>Flexbox 和布局方式</h2><p>flex会创建BFC</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-class">.box</span>&gt;* &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <br></code></pre></td></tr></table></figure><h2 id="Flexbox-和网格布局"><a href="#Flexbox-和网格布局" class="headerlink" title="Flexbox 和网格布局"></a>Flexbox 和网格布局</h2><p>CSS Grid Layout和 Flexbox 通常以相同的方式覆盖其他方法。但是，您可能希望使用 flexbox 作为网格布局的后备，因为在旧浏览器中对 flexbox 有更好的支持。</p><p>这种方法效果很好。如果弹性项目成为网格项目，则flex可能已分配给子元素的属性将被忽略。</p><p>在 Grid Layout 中，您对容器进行大部分尺寸规范，设置轨道，然后将项目放入其中。在 flexbox 中，当您创建一个 flex 容器并在该级别设置方向时，对项目大小的任何控制都需要在项目本身上进行。</p><h2 id="Flexbox-和显示：内容"><a href="#Flexbox-和显示：内容" class="headerlink" title="Flexbox 和显示：内容"></a>Flexbox 和显示：内容</h2><p>该属性的contents值display是规范中描述的新值，如下所示：</p><blockquote><p>“元素本身不会生成任何框，但它的子元素和伪元素仍然照常生成框。出于框生成和布局的目的，必须将元素视为已被文档树中的子元素和伪元素替换。”</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.nested</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: orange;<br>    <span class="hljs-attribute">display</span>: contents;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h2 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">flex<br>flex-basis<br>flex-direction<br>flex-flow<br>flex-grow<br>flex-shrink<br>flex-wrap<br>order<br><br>align-content<br>align-items<br>align-self<br>justify-content<br>place-content<br>row-gap 行间隙<br>column-gap 列间隙<br>gap 行和列间隙，该属性是row-gap和column-gap的简写<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
      <tag>gap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2022/08/24/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2022/08/24/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Flexible-Box-模型"><a href="#Flexible-Box-模型" class="headerlink" title="Flexible Box 模型"></a>Flexible Box 模型</h1><p>是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力</p><h1 id="两根轴线"><a href="#两根轴线" class="headerlink" title="两根轴线"></a>两根轴线</h1><p>当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴。主轴由 <code>flex-direction</code> 定义，另一根轴垂直于它。</p><h2 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h2><p>主轴由 <code>flex-direction</code> 定义，可以取 4 个值：</p><ul><li>row</li><li>row-reverse</li><li>column</li><li>column-reverse</li></ul><p>如果你选择了 row 或者 row-reverse，你的主轴将沿着 inline 方向延伸。</p><p><img src="/img/css/flex01.png"></p><p>选择 <code>column</code> 或者 <code>column-reverse</code> 时，你的主轴会沿着上下方向延伸 — 也就是 block 排列的方向。</p><p><img src="/img/css/flex02.png"></p><h2 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h2><p>交叉轴垂直于主轴，所以如果你的<code>flex-direction</code> (主轴) 设成了 <code>row</code> 或者 <code>row-reverse</code> 的话，交叉轴的方向就是沿着列向下的。</p><p><img src="/img/css/flex03.png"></p><p>如果主轴方向设成了 <code>column</code> 或者 <code>column-reverse</code>，交叉轴就是水平方向。</p><p><img src="/img/css/flex04.png"></p><h1 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h1><p>文档中采用了 flexbox 的区域就叫做 flex 容器。为了创建 <code>flex</code> 容器，我们把一个容器的 <code>display</code> 属性值改为 <code>flex</code> 或者 <code>inline-flex</code></p><p>完成这一步之后，容器中的直系子元素就会变为 <strong>flex 元素</strong>。所有 CSS 属性都会有一个初始值，所以 flex 容器中的所有 flex 元素都会有下列行为：</p><ul><li>元素排列为一行 (flex-direction 属性的初始值是 row)。</li><li>元素从主轴的起始线开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。</li><li>元素被拉伸来填充交叉轴大小。</li><li>flex-basis 属性为 auto。</li><li>flex-wrap 属性为 nowrap。</li></ul><p>这会让你的元素呈线形排列，并且把自己的大小作为主轴上的大小。如果有太多元素超出容器，它们会溢出而<strong>不会换行</strong>。如果一些元素比其他元素高，那么元素会沿交叉轴被拉伸来填满它的大小。</p><h1 id="更改-flex-方向-flex-direction"><a href="#更改-flex-方向-flex-direction" class="headerlink" title="更改 flex 方向 flex-direction"></a>更改 flex 方向 flex-direction</h1><p>把 flex 容器的属性 flex-direction 改为 column ，主轴和交叉轴交换，元素沿着列的方向排列显示。</p><h1 id="用-flex-wrap-实现多行-Flex-容器"><a href="#用-flex-wrap-实现多行-Flex-容器" class="headerlink" title="用 flex-wrap 实现多行 Flex 容器"></a>用 flex-wrap 实现多行 Flex 容器</h1><p>虽然flexbox是一维模型，但可以使我们的flex项目应用到多行中。在这样做的时候，您应该把每一行看作一个新的flex容器。<strong>任何空间分布都将在该行上发生</strong>，而不影响该空间分布的其他行。</p><h1 id="简写属性-flex-flow"><a href="#简写属性-flex-flow" class="headerlink" title="简写属性 flex-flow"></a>简写属性 flex-flow</h1><p>你可以将两个属性 flex-direction 和 flex-wrap 组合为简写属性 flex-flow。第一个指定的值为 flex-direction ，第二个指定的值为 flex-wrap.</p><h1 id="flex-元素上的属性"><a href="#flex-元素上的属性" class="headerlink" title="flex 元素上的属性"></a>flex 元素上的属性</h1><p>为了更好地控制 flex 元素，有三个属性可以作用于它们：</p><ul><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li></ul><p>在考虑这几个属性的作用之前，需要先了解一下 <strong>可用空间 available space</strong> 这个概念。这几个 flex 属性的作用其实就是改变了 flex 容器中的可用空间的行为。同时，可用空间对于 flex 元素的对齐行为也是很重要的。</p><p>假设在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占 300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox 的行为会把这 200px 的空间留在最后一个元素的后面。</p><p><img src="/img/css/flex05.png"></p><h2 id="Flex-元素属性：flex-basis"><a href="#Flex-元素属性：flex-basis" class="headerlink" title="Flex 元素属性：flex-basis"></a>Flex 元素属性：flex-basis</h2><p><strong>flex-basis 定义了该元素的空间大小</strong>（the size of that item in terms of the space），flex 容器里除了元素所占的空间以外的富余空间就是可用空间 available space。 该属性的默认值是 <code>auto</code> 。此时，浏览器会检测这个元素是否具有确定的尺寸。 在上面的例子中，所有元素都设定了宽度（width）为 100px，所以 flex-basis 的值为 100px。</p><p>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素内容的尺寸。这就解释了：我们给只要给 <code>Flex</code> 元素的父元素声明 <code>display: flex</code> ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</p><h2 id="Flex-元素属性：flex-grow"><a href="#Flex-元素属性：flex-grow" class="headerlink" title="Flex 元素属性：flex-grow"></a>Flex 元素属性：flex-grow</h2><p>flex-grow 若被赋值为一个正整数， flex 元素会以 flex-basis 为基础，沿主轴方向增长尺寸。<br>这会使该元素延展，<strong>并占据此方向轴上的可用空间（available space）</strong>。如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。</p><p>如果我们给上例中的所有元素设定 <code>flex-grow</code> 值为 1，容器中的可用空间会被这些元素<strong>平分</strong>。它们会延展以填满容器主轴方向上的空间。</p><p>flex-grow 属性可以按比例分配空间。如果第一个元素 flex-grow 值为 2，其他元素值为 1，则第一个元素将占有 2/4（上例中，即为 200px 中的 100px）, 另外两个元素各占有 1/4（各 50px）。</p><h2 id="Flex-元素属性：-flex-shrink"><a href="#Flex-元素属性：-flex-shrink" class="headerlink" title="Flex 元素属性： flex-shrink"></a>Flex 元素属性： flex-shrink</h2><p>flex-grow属性是处理 flex 元素在主轴上增加空间的问题，相反flex-shrink属性是处理 flex 元素收缩的问题。</p><h2 id="Flex-属性的简写"><a href="#Flex-属性的简写" class="headerlink" title="Flex 属性的简写"></a>Flex 属性的简写</h2><p>你可能很少看到 <code>flex-grow</code>，<code>flex-shrink</code>，和 <code>flex-basis</code> 属性单独使用，而是混合着写在 <code>flex</code> 简写形式中。 Flex 简写形式允许你把三个数值按这个顺序书写 — <code>flex-grow，flex-shrink，flex-basis</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>     <span class="hljs-attribute">display</span>: flex;<br>   &#125;<br><br>   <span class="hljs-selector-class">.one</span> &#123;<br>     <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> auto;<br>   &#125;<br><br>   <span class="hljs-selector-class">.two</span> &#123;<br>     <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> auto;<br>   &#125;<br><br>   <span class="hljs-selector-class">.three</span> &#123;<br>     <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> auto;<br>   &#125;<br>  <br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;three&quot;</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>大多数情况下可以用预定义的简写形式。在这个教程中你可能经常会看到这种写法，许多情况下你都可以这么使用。下面是几种预定义的值：</p><ul><li>flex: initial</li><li>flex: auto</li><li>flex: none</li><li>flex: <positive-number></li></ul><p><code>flex: initial</code> 是把 flex 元素重置为 Flexbox 的初始值，它相当于 flex: 0 1 auto。在这里 flex-grow 的值为 0，所以 flex 元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。 flex-basis 的值为 auto. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。</p><p><code>flex: auto</code> 等同于 flex: 1 1 auto；和上面的 flex:initial 基本相同，但是这种情况下，flex 元素在需要的时候既可以拉伸也可以收缩。</p><p><code>flex: none</code> 可以把 flex 元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的 flexbox 进行布局。</p><p><code>flex: &lt;positive-number&gt;</code> 你在教程中常看到的 flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0。元素可以在flex-basis为 0 的基础上伸缩。</p><h1 id="元素间的对齐和空间分配"><a href="#元素间的对齐和空间分配" class="headerlink" title="元素间的对齐和空间分配"></a>元素间的对齐和空间分配</h1><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p><code>Flexbox</code> 的一个关键特性是能够设置 flex 元素沿主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。<br><code>align-items align-items</code> 属性可以使元素在交叉轴方向对齐。</p><p><code>这个属性的初始值为stretch</code>，这就是为什么 <code>flex</code> 元素会默认被拉伸到最高元素的高度。实际上，它们被拉伸来填满 flex 容器 —— <strong>最高的元素定义了容器的高度</strong>。</p><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p><code>justify-content</code>属性用来使元素在主轴方向上对齐，主轴方向是通过 flex-direction 设置的方向。初始值是flex-start，元素从容器的起始线排列。但是你也可以把值设置为flex-end，从终止线开始排列，或者center，在中间排列。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>flex</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS有用的代码片段</title>
    <link href="/2022/08/24/JS%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    <url>/2022/08/24/JS%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="检查浏览器"><a href="#检查浏览器" class="headerlink" title="检查浏览器"></a>检查浏览器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isBrowser</span> = (<span class="hljs-params"></span>) =&gt; ![<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span>, <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;undefined&#x27;</span>);<br><span class="hljs-title function_">isBrowser</span>() <span class="hljs-comment">// true   if on isBrowser</span><br><span class="hljs-title function_">isBrowser</span>() <span class="hljs-comment">// false  if we are on node js or any other environment</span><br></code></pre></td></tr></table></figure><h2 id="检查是否为数字"><a href="#检查是否为数字" class="headerlink" title="检查是否为数字"></a>检查是否为数字</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isNumeric</span>(<span class="hljs-params">num</span>) &#123; <br>  <span class="hljs-keyword">return</span> !<span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">parseFloat</span>(num)) &amp;&amp; <span class="hljs-built_in">isFinite</span>(num); <br>&#125;<br><span class="hljs-title function_">isNumeric</span>(<span class="hljs-number">324</span>) <span class="hljs-comment">//true </span><br><span class="hljs-title function_">isNumeric</span>(<span class="hljs-string">&quot;Code&quot;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="检查是否为字符串"><a href="#检查是否为字符串" class="headerlink" title="检查是否为字符串"></a>检查是否为字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isString</span> = val =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;string&#x27;</span>;<br><span class="hljs-title function_">isString</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">isString</span>(<span class="hljs-string">&#x27;1234&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-title function_">isString</span>(<span class="hljs-number">345</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">maxN</span> = (<span class="hljs-params">arr, n = <span class="hljs-number">1</span></span>) =&gt; [...arr].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a).<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, n);<br><span class="hljs-title function_">maxN</span>([<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>]) <span class="hljs-comment">// 8 </span><br><span class="hljs-title function_">maxN</span>([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">23</span>]) <span class="hljs-comment">// 23</span><br></code></pre></td></tr></table></figure><h2 id="从列表中随机"><a href="#从列表中随机" class="headerlink" title="从列表中随机"></a>从列表中随机</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">random</span> = arr =&gt; arr[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * arr.<span class="hljs-property">length</span>)];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">random</span>([<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])) <span class="hljs-comment">// 6 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">random</span>([<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>])) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="范围生成器中的整数数组"><a href="#范围生成器中的整数数组" class="headerlink" title="范围生成器中的整数数组"></a>范围生成器中的整数数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">randomIntArrayInRange</span> = (<span class="hljs-params">min, max, n = <span class="hljs-number">1</span></span>) =&gt; <br>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(&#123; <span class="hljs-attr">length</span>: n &#125;, <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (max - min + <span class="hljs-number">1</span>)) + min);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">randomIntArrayInRange</span>(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// [ 14, 11, 15, 10, 13 ]</span><br></code></pre></td></tr></table></figure><h2 id="范围生成器中的随机整数"><a href="#范围生成器中的随机整数" class="headerlink" title="范围生成器中的随机整数"></a>范围生成器中的随机整数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">randomInteger</span> = (<span class="hljs-params">min, max</span>) =&gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (max - min + <span class="hljs-number">1</span>)) + min;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">randomInteger</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)) <span class="hljs-comment">// 6 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">randomInteger</span>(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><h2 id="获取类型"><a href="#获取类型" class="headerlink" title="获取类型"></a>获取类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getType</span> = v =&gt; v === <span class="hljs-literal">undefined</span> ? <span class="hljs-string">&#x27;undefined&#x27;</span> : v === <span class="hljs-literal">null</span> ? <span class="hljs-string">&#x27;null&#x27;</span> : v.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>();<br><span class="hljs-title function_">getType</span>([<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment">//array</span><br><span class="hljs-title function_">getType</span>(<span class="hljs-string">&quot;JavaScript&quot;</span>)  <span class="hljs-comment">//string</span><br><span class="hljs-title function_">getType</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">//boolean</span><br></code></pre></td></tr></table></figure><h2 id="数组平均数"><a href="#数组平均数" class="headerlink" title="数组平均数"></a>数组平均数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">average</span> = arr =&gt; arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, val</span>) =&gt;</span> acc + val, <span class="hljs-number">0</span>) / arr.<span class="hljs-property">length</span>;<br><br><span class="hljs-comment">// average([1,2,3]) -&gt; 2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/24/hello-world/"/>
    <url>/2022/08/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
